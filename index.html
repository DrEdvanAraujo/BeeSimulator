<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jardim 3D - Miss√µes Pacientes V11 (Firepit & Wood)</title>
    <style>
        /* CSS identical to previous version */
        /* --- Base Styles --- */
        body, html { margin: 0; padding: 0; overflow: hidden; font-family: 'Arial', sans-serif; background-color: #e0f2f7; height: 100%; width: 100%; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; }
        #canvas-container.pointer-locked { cursor: none; }
        canvas { display: block; }

        /* --- Info Panel --- */
        #info-panel { position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.97); padding: 20px; border-radius: 12px; width: 320px; max-width: 85%; max-height: calc(100vh - 230px); overflow-y: auto; z-index: 10; color: #333; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); visibility: hidden; opacity: 0; transition: opacity 0.4s ease, visibility 0s linear 0.4s; border-left: 5px solid #4CAF50; }
        #info-panel.visible { visibility: visible; opacity: 1; transition: opacity 0.4s ease; }
        #info-panel h3 { margin-top: 0; margin-bottom: 15px; color: #2E7D32; border-bottom: 1px solid #ccc; padding-bottom: 10px; display: flex; align-items: center; gap: 8px; }
        #info-panel h3::before { content: 'üåø'; font-size: 1.2em; }
        #info-panel p { margin-bottom: 12px; line-height: 1.6; font-size: 0.95em; }
        #info-panel p strong { color: #4CAF50; }
        #info-panel a.educational-link { display: inline-block; margin-top: 10px; padding: 8px 15px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 5px; transition: background-color 0.2s ease; font-size: 0.9em; }
        #info-panel a.educational-link:hover { background-color: #388E3C; }
        #close-info { position: absolute; top: 10px; right: 10px; cursor: pointer; background: #e0e0e0; color: #555; border: none; border-radius: 50%; width: 28px; height: 28px; font-size: 16px; line-height: 28px; text-align: center; transition: background-color 0.2s ease, color 0.2s ease; }
        #close-info:hover { background-color: #f44336; color: white; }

        /* --- Right Panel Container --- */
        #right-panel-container { position: absolute; top: 20px; right: 20px; width: 350px; max-width: 90%; max-height: calc(100vh - 40px); display: flex; flex-direction: column; gap: 15px; z-index: 5; }

        /* --- Mission Panel --- */
        #mission-panel { background: rgba(0, 51, 51, 0.85); color: #e0f2f7; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); overflow-y: auto; font-size: 0.9em; border-left: 4px solid #80cbc4; flex-shrink: 1; min-height: 150px; }
        #mission-panel h4 { border-bottom: 1px solid #80cbc4; padding-bottom: 8px; margin-top: 0; margin-bottom: 10px; color: #ffffff; font-weight: bold; }
        #mission-panel h5 { margin-top: 15px; margin-bottom: 8px; color: #b2dfdb; font-weight: bold; }
        #current-mission { padding: 10px; background-color: rgba(255, 255, 255, 0.1); border-radius: 5px; margin-bottom: 15px; border-left: 3px solid #ffeb3b; min-height: 30px; line-height: 1.5; }
        #knowledge-base ul, #crafted-items ul, #extracted-oils ul { list-style: none; padding-left: 0; margin: 0 0 10px 0; }
        #knowledge-base li, #crafted-items li, #extracted-oils li { margin-bottom: 5px; padding-left: 20px; position: relative; line-height: 1.4; }
        #knowledge-base li::before { content: 'üåø'; position: absolute; left: 0; color: #a5d6a7; font-size: 1em; top: 1px; }
        #crafted-items li { color: #ffcc80; }
        #crafted-items li::before { content: 'üçµ'; position: absolute; left: 0; color: #ffcc80; font-size: 1em; top: 1px; }
        #extracted-oils li { color: #ce93d8; }
        #extracted-oils li::before { content: 'üíß'; position: absolute; left: 0; color: #ce93d8; font-size: 1em; top: 1px; }
        #status-message { margin-top: 15px; padding: 10px; background-color: rgba(0, 0, 0, 0.3); border-radius: 5px; min-height: 35px; font-style: italic; color: #b2dfdb; line-height: 1.4; transition: opacity 0.5s ease; }
        hr.mission-divider { border: none; height: 1px; background-color: rgba(128, 203, 196, 0.4); margin: 15px 0; }

        /* --- Inventory Panel --- */
        #inventory-panel { background: rgba(51, 0, 51, 0.8); color: #f3e5f5; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); font-size: 0.85em; border-left: 4px solid #ce93d8; flex-shrink: 0; }
        #inventory-panel h4 { border-bottom: 1px solid #ce93d8; padding-bottom: 8px; margin-top: 0; margin-bottom: 10px; color: #ffffff; font-weight: bold; }
        #inventory-list li, #bench-inventory-list li { color: #e1bee7; margin-bottom: 5px; padding-left: 20px; position: relative; line-height: 1.4; }
        #inventory-list li::before, #bench-inventory-list li::before { content: ''; position: absolute; left: 0; color: #e1bee7; font-size: 1em; top: 1px; }
        #inventory-list li[data-type="plant"]::before, #bench-inventory-list li[data-type="plant"]::before { content: 'üå±'; }
        #inventory-list li[data-type="water"]::before, #bench-inventory-list li[data-type="water"]::before { content: 'üíß'; color: #90caf9; }
        #inventory-list li[data-type="wood"]::before { content: 'ü™µ'; color: #bcaaa4; } /* NEW: Wood icon */
        #bench-inventory-list li[data-type="wood"]::before { content: 'ü™µ'; color: #bcaaa4; } /* NEW: Wood icon */
        .inventory-section h5 { margin-top: 10px; margin-bottom: 5px; color: #f3e5f5; font-size: 0.9em; border-bottom: 1px dashed rgba(243, 229, 245, 0.5); padding-bottom: 3px;}
        #inventory-list, #bench-inventory-list { list-style: none; padding-left: 0; margin: 0; }

        /* --- UI Elements --- */
        #instructions { position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.75); color: white; padding: 10px 20px; border-radius: 20px; font-size: 0.9em; z-index: 3; pointer-events: none; opacity: 1; transition: opacity 1s ease 4s; text-align: center; }
        #instructions.hidden { opacity: 0; }
        #controls-toggle { position: absolute; bottom: 20px; left: 20px; padding: 10px 15px; background-color: #607D8B; color: white; border: none; border-radius: 5px; cursor: pointer; z-index: 5; font-size: 0.9em; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: white; border-radius: 50%; transform: translate(-50%, -50%); z-index: 5; mix-blend-mode: difference; display: none; pointer-events: none;}
        #canvas-container.pointer-locked ~ #crosshair { display: block; }
        #minimap-container { position: absolute; bottom: 20px; right: 20px; /* Now sibling to right-panel */ width: 150px; height: 150px; border: 2px solid rgba(255, 255, 255, 0.6); background-color: rgba(0, 0, 0, 0.7); border-radius: 8px; z-index: 4; overflow: hidden; box-shadow: 0 0 10px rgba(0,0,0,0.3); }
        #minimap-canvas { width: 100%; height: 100%; display: block; }
        #interaction-prompt { position: absolute; top: 55%; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 0.8em; z-index: 6; display: none; pointer-events: none; }
        #canvas-container.pointer-locked ~ #interaction-prompt.visible { display: block; }
        #bee-balloon { position: absolute; display: none; background: #fff8c6; border-radius: 10px; box-shadow: 0 0 6px #999; font-weight: bold; padding: 8px 12px; z-index: 15; color: #444; pointer-events: none; }

        /* --- Plant Labels --- */
        #plant-labels-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 2; }
        .plant-label { position: absolute; background-color: rgba(0, 0, 0, 0.65); color: #f0f0f0; padding: 4px 9px; border-radius: 5px; font-size: 12px; white-space: nowrap; transform: translate(-50%, -50%); user-select: none; display: none; opacity: 0; transition: opacity 0.3s ease; }
        .plant-label.visible { display: block; }
        @keyframes pulse-fade { 0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(0.98); } 50% { opacity: 0.9; transform: translate(-50%, -50%) scale(1.02); } }
        .plant-label.pulsing { animation: pulse-fade 2s infinite ease-in-out; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="plant-labels-container"></div> <div id="crosshair"></div>
    <div id="interaction-prompt">Pressione [E] para Interagir</div>
    <div id="info-panel">
        <button id="close-info" title="Fechar">√ó</button>
        <h3 id="plant-name">Nome da Planta</h3> <p><strong>Grupo:</strong> <span id="plant-group"></span></p>
        <p><strong>Benef√≠cios / Descri√ß√£o:</strong></p>
        <p id="plant-benefits">Detalhes...</p>
        <a id="plant-link" href="#" target="_blank" class="educational-link">Saiba Mais</a>
    </div>
    <div id="right-panel-container">
         <div id="inventory-panel">
             <h4>Invent√°rio üéí</h4>
             <div class="inventory-section">
                 <h5>Carregando (M√°x: <span id="max-plant-inv">5</span> plantas, <span id="max-wood-inv">10</span> lenhas):</h5>
                 <ul id="inventory-list"></ul>
             </div>
             <div class="inventory-section">
                 <h5>Na Bancada ‚öóÔ∏è:</h5>
                 <ul id="bench-inventory-list"></ul>
             </div>
         </div>
        <div id="mission-panel">
            <h4>Di√°rio do Herbalista üìú</h4>
            <h5>Miss√£o Atual:</h5>
            <div id="current-mission">Carregando...</div>
            <hr class="mission-divider">
            <h5>Base de Conhecimento:</h5>
            <div id="knowledge-base"><ul></ul></div>
            <hr class="mission-divider">
            <h5>Prepara√ß√µes Feitas:</h5>
            <div id="crafted-items"><ul></ul></div>
            <hr class="mission-divider">
            <h5>√ìleos Essenciais Extra√≠dos:</h5>
            <div id="extracted-oils"><ul></ul></div>
            <hr class="mission-divider">
            <div id="status-message">Explore o jardim...</div>
        </div>
    </div>
    <div id="instructions">
        Orbital: Clique/Arraste, Scroll, Clique obj.<br>
        Pessoal: [CLIQUE BOT√ÉO], W/A/S/D, Mouse, [E] Ver Info/Falar, [F] Coletar Planta/Lenha/Depositar, [G] Usar Bancada(Ch√°)/Fogueira(√ìleo), [ESC] Sair.<br>
        (Passe perto do Recurso de √Ågua üíß para coletar)
    </div>
    <button id="controls-toggle">Ativar Vis√£o Pessoal</button>
    <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>
    <div id="bee-balloon">üêù O Poder das Abelhas - Apiterapia - Interagir [F]</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        // --- Basic Setup ---
        let currentControlsMode = 'orbit';
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xADD8E6);
        scene.fog = new THREE.Fog(0xADD8E6, 20, 70);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 14); camera.lookAt(0, 0.5, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.appendChild(renderer.domElement);
        const clock = new THREE.Clock();
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(20, 25, 15); directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 80;
        directionalLight.shadow.camera.left = -30; directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30; directionalLight.shadow.camera.bottom = -30;
        scene.add(directionalLight);
        const groundGeometry = new THREE.PlaneGeometry(80, 80);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x7CB342, side: THREE.DoubleSide, roughness: 0.9, metalness: 0.0 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);

        // --- Constants ---
        const PLANT_RESPAWN_TIME = 45.0;
        const WOOD_RESPAWN_TIME = 60.0; // NEW: Wood respawn time
        const WATER_COLLECT_AMOUNT = 3;
        const MAX_PLAYER_PLANT_INVENTORY = 5;
        const MAX_PLAYER_WOOD_INVENTORY = 10; // NEW: Wood inventory limit
        const WATER_RESOURCE_RESPAWN_TIME = 5.0; // seconds
        const WATER_RESOURCE_COLLECT_DISTANCE = 1.2; // How close player needs to be
        const WOOD_FOR_OIL = 3; // NEW: Wood needed per oil extraction
        document.getElementById('max-plant-inv').textContent = MAX_PLAYER_PLANT_INVENTORY;
        document.getElementById('max-wood-inv').textContent = MAX_PLAYER_WOOD_INVENTORY; // NEW: Update UI

        // --- Plant Data & Groups ---
        const plantGroups = { /* ... unchanged ... */
            calmantes: { name: 'Calmantes', position: new THREE.Vector3(-8, 0, -8), color: 0xba68c8 },
            digestivas: { name: 'Digestivas', position: new THREE.Vector3(8, 0, -8), color: 0xcddc39 },
            respiratorias: { name: 'Respirat√≥rias', position: new THREE.Vector3(-8, 0, 8), color: 0x4db6ac },
            cicatrizantes: { name: 'Cicatrizantes / Pele', position: new THREE.Vector3(8, 0, 8), color: 0xfdd835 },
            citricos_energia: { name: 'C√≠tricos / Energia', position: new THREE.Vector3(0, 0, -12), color: 0xFF9800 },
            outros: { name: 'Purificantes / Outros', position: new THREE.Vector3(0, 0, 12), color: 0x8BC34A }
        };
        const plantasData = [ /* ... unchanged ... */
            // Calmantes
            { id: 'camomila', name: 'Camomila', group: 'calmantes', color: 0xffeb3b, desc: 'Calmante natural, auxilia no sono e digest√£o. Usada para ansiedade, ins√¥nia e problemas digestivos leves. Ch√° √© a forma mais comum.', link: '#camomila-info', shape: 'flower', info_viewed: false },
            { id: 'lavanda', name: 'Lavanda', group: 'calmantes', color: 0xba68c8, desc: 'üíú Aroma floral, suave e reconfortante. Reduz ansiedade e ins√¥nia. √ìleo essencial para relaxamento.', link: '#lavanda-info', shape: 'tall_flower', info_viewed: false },
            { id: 'capim-limao', name: 'Capim-Lim√£o', group: 'calmantes', color: 0xa5d6a7, desc: 'üçã Aroma suave, c√≠trico e relaxante. Calmante, alivia ansiedade e ins√¥nia. Traz equil√≠brio.', link: '#capimlimao-info', shape: 'bush', info_viewed: false },
            { id: 'passiflora', name: 'Passiflora (Maracuj√°)', group: 'calmantes', color: 0x8e44ad, desc: 'Auxilia no al√≠vio de ansiedade, agita√ß√£o e ins√¥nia. Comum em fitoter√°picos.', link: '#passiflora-info', shape:'vine_flower', info_viewed: false},
             // Digestivas
            { id: 'hortela-pimenta', name: 'Hortel√£-Pimenta', group: 'digestivas', color: 0x4caf50, desc: 'üåø Aroma fresco, mentolado e revigorante. Alivia problemas digestivos. √ìleo essencial usado para clareza mental e foco.', link: '#hortela-info', shape: 'bush', info_viewed: false },
            { id: 'boldo', name: 'Boldo', group: 'digestivas', color: 0x558b2f, desc: 'Auxilia na digest√£o e no funcionamento do f√≠gado. Usado ap√≥s excessos alimentares.', link: '#boldo-info', shape: 'large_leaf_bush', info_viewed: false },
            { id: 'erva-doce', name: 'Erva-doce (Funcho)', group: 'digestivas', color: 0xcddc39, desc: 'Ajuda na digest√£o, reduz c√≥licas e gases.', link: '#ervadoce-info', shape: 'tall_thin', info_viewed: false },
            { id: 'espinheira-santa', name: 'Espinheira Santa', group: 'digestivas', color: 0x689f38, desc: 'Indicada para m√° digest√£o, gastrite e √∫lcera g√°strica (coadjuvante).', link: '#espinheira-info', shape:'spiky_bush', info_viewed: false},
            { id: 'alcachofra', name: 'Alcachofra', group: 'digestivas', color: 0x795548, desc: 'Auxilia na digest√£o de gorduras e em problemas disp√©pticos.', link: '#alcachofra-info', shape:'artichoke_like', info_viewed: false},
              // Respirat√≥rias
            { id: 'guaco', name: 'Guaco', group: 'respiratorias', color: 0x2e7d32, desc: 'Expectorante e broncodilatador natural, indicado para tosses e bronquites.', link: '#guaco-info', shape: 'vine_leaf', info_viewed: false },
            { id: 'eucalipto', name: 'Eucalipto', group: 'respiratorias', color: 0x4db6ac, desc: 'Descongestionante, utilizado em inala√ß√µes para problemas respirat√≥rios.', link: '#eucalipto-info', shape: 'tall_tree_like', info_viewed: false },
            { id: 'malva', name: 'Malva', group: 'respiratorias', color: 0x9575cd, desc: 'A√ß√£o emoliente, usada para aliviar inflama√ß√µes na boca, garganta e tosse seca.', link: '#malva-info', shape: 'flower_pink', info_viewed: false },
                // Cicatrizantes / Pele
            { id: 'babosa', name: 'Babosa (Aloe vera)', group: 'cicatrizantes', color: 0x81d4fa, desc: 'Gel usado topicamente em queimaduras leves, cortes e para hidrata√ß√£o.', link: '#babosa-info', shape: 'aloe', info_viewed: false },
            { id: 'calendula', name: 'Cal√™ndula', group: 'cicatrizantes', color: 0xfdd835, desc: 'Cicatrizante e anti-inflamat√≥ria potente, usada topicamente para pele.', link: '#calendula-info', shape: 'flower_orange', info_viewed: false },
            { id: 'arnica', name: 'Arnica (Arnica montana)', group: 'cicatrizantes', color: 0xffc107, desc: 'Anti-inflamat√≥ria, usada topicamente para contus√µes e dores musculares. *N√£o ingerir*.', link: '#arnica-info', shape: 'flower_yellow', info_viewed: false },
            { id: 'melaleuca', name: 'Melaleuca (Tea Tree)', group: 'cicatrizantes', color: 0x80cbc4, desc: 'üå≥ Aroma fresco, herb√°ceo e purificante. Antiss√©ptico natural, cuidado para pele e ambiente.', link: '#melaleuca-info', shape: 'tall_thin_bushy', info_viewed: false },
                // C√≠tricos / Energia
            { id: 'laranja-doce', name: 'Laranja Doce', group: 'citricos_energia', color: 0xFFB74D, desc: 'üçä Aroma doce, c√≠trico e envolvente. Traz energia, alegria e leveza.', link: '#laranja-info', shape: 'bush_round_orange', info_viewed: false },
            { id: 'alecrim', name: 'Alecrim', group: 'citricos_energia', color: 0x8bc34a, desc: 'üå± Aroma herb√°ceo, estimulante. Melhora mem√≥ria e concentra√ß√£o. Renova√ß√£o e disposi√ß√£o.', link: '#alecrim-info', shape: 'rosemary', info_viewed: false },
                // Purificantes / Outros
            { id: 'alfavaca', name: 'Alfavaca (Manjeric√£o)', group: 'outros', color: 0x7cb342, desc: 'Antioxidante, auxilia na digest√£o e sistema imunol√≥gico. Propriedades calmantes leves.', link: '#alfavaca-info', shape: 'bush_round', info_viewed: false },
            { id: 'salvia', name: 'S√°lvia', group: 'outros', color: 0x6d4c41, desc: 'Antiss√©ptica e anti-inflamat√≥ria, usada em gargarejos e para equilibrar horm√¥nios.', link: '#salvia-info', shape: 'bush_grey', info_viewed: false },
            { id: 'garra-do-diabo', name: 'Garra do Diabo', group: 'outros', color: 0xb71c1c, desc: 'Al√≠vio de dores articulares moderadas e dor lombar.', link: '#garra-info', shape:'low_spiky', info_viewed: false},
        ];

        // NEW: Wood Data
        const woodData = [
             { id: 'wood_pile_1', name: 'Pilha de Lenha', desc: 'Lenha seca, boa para a fogueira.', color: 0x8D6E63, position: new THREE.Vector3(10, 0, 10), info_viewed: false },
             { id: 'wood_pile_2', name: 'Pilha de Lenha', desc: 'Lenha seca, boa para a fogueira.', color: 0x8D6E63, position: new THREE.Vector3(-10, 0, 10), info_viewed: false },
             { id: 'wood_pile_3', name: 'Pilha de Lenha', desc: 'Lenha seca, boa para a fogueira.', color: 0x8D6E63, position: new THREE.Vector3(10, 0, -10), info_viewed: false },
             { id: 'wood_pile_4', name: 'Pilha de Lenha', desc: 'Lenha seca, boa para a fogueira.', color: 0x8D6E63, position: new THREE.Vector3(-10, 0, -10), info_viewed: false },
        ];

        // --- NPC Data ---
        const npcsData = [ /* ... unchanged ... */
            { id: 'npc_ana', name: 'Ana', position: new THREE.Vector3(-6, 0, -6), color: 0xffa07a, condition: 'Ansiedade e dificuldade para dormir', requiredItemType: 'phyto', requiredItemId: 'cha_camomila', dialogue: { initial: "Ol√°! Ultimamente ando t√£o ansiosa... Mal consigo dormir. üòî", reminder: "Voc√™ conseguiu encontrar algo que possa me ajudar a relaxar?", thanks: "Nossa, este ch√° parece t√£o calmante! Muito obrigada! Sinto-me melhor s√≥ de sentir o aroma. üôè" } },
            { id: 'npc_carlos', name: 'Carlos', position: new THREE.Vector3(6, 0, -6), color: 0xadd8e6, condition: 'Indigest√£o frequente ap√≥s as refei√ß√µes', requiredItemType: 'phyto', requiredItemId: 'cha_hortela', dialogue: { initial: "Oi! Minha digest√£o n√£o anda nada bem ultimamente. Fico com aquela sensa√ß√£o de peso...", reminder: "Alguma novidade sobre algo para ajudar minha digest√£o?", thanks: "Ah, hortel√£! Dizem que √© √≥timo. Vou experimentar. Muito obrigado pela ajuda! üëç" } },
            { id: 'npc_julia', name: 'Julia', position: new THREE.Vector3(-1, 0, -10), color: 0x90ee90, condition: 'Sentindo-se desanimada e sem energia', requiredItemType: 'oil', requiredItemId: 'oleo_laranja_doce', dialogue: { initial: "Sinto-me t√£o sem energia ultimamente... precisava de algo para me animar um pouco. ‚òÄÔ∏è", reminder: "Encontrou algo que possa me dar um 'up'?", thanks: "Uau, √≥leo de Laranja Doce! O cheiro √© maravilhoso, j√° me sinto mais alegre! Obrigada! üòÑ" } },
            { id: 'npc_rafael', name: 'Rafael', position: new THREE.Vector3(-5, 0, 5), color: 0xd8bfd8, condition: 'Precisando de foco para estudar', requiredItemType: 'oil', requiredItemId: 'oleo_alecrim', dialogue: { initial: "Tenho uma prova importante, mas n√£o consigo me concentrar de jeito nenhum! üìö", reminder: "Ainda preciso daquela ajuda para focar nos estudos...", thanks: "√ìleo de Alecrim? Ouvi falar que ajuda na concentra√ß√£o! Perfeito, muito obrigado! üß†" } }
        ];

        // --- Game State ---
        const gameState = {
            currentMissionIndex: 0,
            knowledgeBase: {},
            craftedItems: {},
            extractedOils: {},
            inventory: { water: 0, wood: 0 }, // Added wood to inventory
            benchInventory: {}, // Bench only holds plants and water (if deposited, though unlikely)
            npcStates: {},
            canCollectPlant: false,
            canCollectWood: false, // NEW: Ability to collect wood
            canCraftPhyto: false,
            canExtractOil: false,
            gameComplete: false,
            isWaterResourceAvailable: false,
            waterResourceRespawnTimer: WATER_RESOURCE_RESPAWN_TIME
        };

        // --- Oil IDs & Recipes ---
        const OIL_LAVENDER = 'oleo_lavanda'; const OIL_PEPPERMINT = 'oleo_hortela_pimenta'; const OIL_EUCALYPTUS = 'oleo_eucalipto'; const OIL_ROSEMARY = 'oleo_alecrim'; const OIL_LEMONGRASS = 'oleo_capim_limao'; const OIL_ORANGE = 'oleo_laranja_doce'; const OIL_TEA_TREE = 'oleo_melaleuca';
        const recipes = { /* ... unchanged ... */
            cha_camomila: { name: "Ch√° de Camomila", ingredients: { camomila: 2, water: 1 }, type: 'phyto' },
            cha_hortela: { name: "Ch√° de Hortel√£-Pimenta", ingredients: { 'hortela-pimenta': 2, water: 1 }, type: 'phyto' },
            cha_capim_limao: { name: "Ch√° de Capim-Lim√£o", ingredients: { 'capim-limao': 2, water: 1 }, type: 'phyto' },
        };

        // --- Mission Helper ---
        function getOilDisplayName(oilId) { /* ... unchanged ... */ switch(oilId) { case OIL_LAVENDER: return 'Lavanda'; case OIL_PEPPERMINT: return 'Hortel√£-Pimenta'; case OIL_EUCALYPTUS: return 'Eucalipto'; case OIL_ROSEMARY: return 'Alecrim'; case OIL_LEMONGRASS: return 'Capim-Lim√£o'; case OIL_ORANGE: return 'Laranja Doce'; case OIL_TEA_TREE: return 'Melaleuca (Tea Tree)'; default: return oilId; } }
        function getRecipeDisplayName(recipeId) { return recipes[recipeId]?.name || recipeId; }
        function getItemDisplayName(itemId) { /* ... getItemDisplayName (Added wood) ... */
            if (itemId === 'water') return '√Ågua';
            if (itemId === 'wood') return 'Lenha'; // NEW
            const plant = plantasData.find(p => p.id === itemId); if (plant) return plant.name;
            const recipe = recipes[itemId]; if (recipe) return recipe.name;
            const oilName = getOilDisplayName(itemId); if (oilName !== itemId) return `√ìleo de ${oilName}`;
            return itemId;
        }


        // --- Missions (Updated for Firepit/Wood) ---
        const missions = [
            // Introduction & Basic Skills
            { id: 'm01_intro', type: 'message', description: "Bem-vindo! Explore o jardim. Use [E] para ver informa√ß√µes das plantas ou falar com pessoas." },
            { id: 'm02_unlock_collect_plant', type: 'unlock_feature', feature: 'collect_plant', description: "Voc√™ sente que j√° pode [coletar plantas]. Aproxime-se e use [F]." },
            { id: 'm03_collect_new_water', type: 'collect_or_deposit', item: 'water', amount: WATER_COLLECT_AMOUNT, description: `Colete o [Recurso de √Ågua üíß] que aparece na fonte (passe perto em vis√£o pessoal). A √°gua √© essencial para as plantas renascerem!` },
            { id: 'm04_find_bench', type: 'find_object', targetObjectId: 'crafting_bench', description: "Localize a [Bancada de Preparo ‚öóÔ∏è]. Ela ser√° essencial para ch√°s." },
            { id: 'm05_unlock_deposit', type: 'unlock_feature', feature: 'deposit', description: "Na bancada, voc√™ pode [depositar plantas [F]] para liberar espa√ßo no seu invent√°rio (M√°x: "+MAX_PLAYER_PLANT_INVENTORY+")." },
            { id: 'm06_unlock_phyto', type: 'unlock_feature', feature: 'phyto', description: "Voc√™ aprendeu o b√°sico! Agora pode [preparar ch√°s [G]] na bancada usando os itens depositados." },
            { id: 'm07_unlock_collect_wood', type: 'unlock_feature', feature: 'collect_wood', description: "Voc√™ percebeu pilhas de [lenha ü™µ] pelo jardim. Colete-as [F]. Ser√£o √∫teis depois." }, // NEW: Unlock wood collection

            // Ana's Mission (Anxiety/Sleep - Camomile Tea)
            { id: 'p01_find_ana', type: 'find_npc', targetNpcId: 'npc_ana', description: "Parece que [Ana], perto das plantas calmantes, precisa de ajuda. Fale com ela [E]." },
            { id: 'p02_ana_needs_tea', type: 'npc_dialogue', targetNpcId: 'npc_ana', requiredDialogue: 'initial', description: "Ana precisa de ajuda para [ansiedade/sono]. Um [Ch√° de Camomila üçµ] pode ajudar." },
            { id: 'p03_collect_camomila', type: 'collect_or_deposit', item: 'camomila', amount: 2, description: "Colete ou tenha na bancada [2 Camomilas üåº] para o ch√° de Ana." },
            { id: 'p04_collect_water_ana', type: 'collect_or_deposit', item: 'water', amount: 1, description: "Obtenha [1 √Ågua üíß] para o ch√° de Ana (colete o recurso na fonte)." },
            { id: 'p05_craft_cha_camomila', type: 'craft_item', recipeId: 'cha_camomila', description: "Prepare o [Ch√° de Camomila üçµ] na bancada [G] para Ana." },
            { id: 'p06_deliver_tea_ana', type: 'deliver_item_to_npc', targetNpcId: 'npc_ana', requiredItemType: 'phyto', requiredItemId: 'cha_camomila', description: "Entregue o [Ch√° de Camomila üçµ] para [Ana] [E]." },

             // Carlos's Mission (Digestion - Peppermint Tea)
            { id: 'p07_find_carlos', type: 'find_npc', targetNpcId: 'npc_carlos', description: "Pr√≥ximo √†s plantas digestivas, [Carlos] parece desconfort√°vel. Fale com ele [E]." },
            { id: 'p08_carlos_needs_tea', type: 'npc_dialogue', targetNpcId: 'npc_carlos', requiredDialogue: 'initial', description: "Carlos est√° com [indigest√£o]. Um [Ch√° de Hortel√£-Pimenta üçµ] pode ser √∫til." },
            { id: 'p09_collect_hortela', type: 'collect_or_deposit', item: 'hortela-pimenta', amount: 2, description: "Consiga [2 Hortel√£s-Pimenta üå±] para o ch√° de Carlos." },
            { id: 'p10_collect_water_carlos', type: 'collect_or_deposit', item: 'water', amount: 1, description: "Obtenha [1 √Ågua üíß] para o ch√° de Carlos." },
            { id: 'p11_craft_cha_hortela', type: 'craft_item', recipeId: 'cha_hortela', description: "Fa√ßa o [Ch√° de Hortel√£-Pimenta üçµ] na bancada [G] para Carlos." },
            { id: 'p12_deliver_tea_carlos', type: 'deliver_item_to_npc', targetNpcId: 'npc_carlos', requiredItemType: 'phyto', requiredItemId: 'cha_hortela', description: "Entregue o [Ch√° de Hortel√£-Pimenta üçµ] para [Carlos] [E]." },

             // Unlock Oils & Firepit
             { id: 'm13_find_firepit', type: 'find_object', targetObjectId: 'firepit', description: "Voc√™ encontrou uma [Fogueira üî•]. Parece ser usada para processos mais complexos." }, // NEW: Find firepit
             { id: 'm14_unlock_oils', type: 'unlock_feature', feature: 'oils', description: "Voc√™ dominou os ch√°s! Agora pode [extrair √ìleos Essenciais [G]] na Fogueira (requer plantas da bancada e lenha do invent√°rio)." }, // MODIFIED: Unlock oils at firepit

             // Julia's Mission (Energy - Orange Oil)
            { id: 'p15_find_julia', type: 'find_npc', targetNpcId: 'npc_julia', description: "[Julia], perto das plantas c√≠tricas, parece desanimada. Fale com ela [E]." },
            { id: 'p16_julia_needs_oil', type: 'npc_dialogue', targetNpcId: 'npc_julia', requiredDialogue: 'initial', description: "Julia precisa de [energia e alegria]. O [√ìleo Essencial de Laranja Doce üíß] pode ajudar." },
            { id: 'p17_collect_laranja', type: 'collect_or_deposit', item: 'laranja-doce', amount: 5, description: "Consiga [5 Laranjas Doces üçä] (na bancada) para o √≥leo de Julia." },
            { id: 'p18_collect_wood_julia', type: 'collect_or_deposit', item: 'wood', amount: WOOD_FOR_OIL, description: `Colete [${WOOD_FOR_OIL} Lenhas ü™µ] para usar na fogueira.` }, // NEW: Collect wood
            { id: 'p19_extract_orange', type: 'extract_oil', targetOilId: OIL_ORANGE, requiresPlantIds: ['laranja-doce'], plantAmount: 5, requiresWoodAmount: WOOD_FOR_OIL, description: `Use a [Fogueira üî• [G]] para extrair o √ìleo Essencial de [${getOilDisplayName(OIL_ORANGE)}] (requer lenha e plantas na bancada).` }, // MODIFIED: Extract at firepit
            { id: 'p20_deliver_oil_julia', type: 'deliver_item_to_npc', targetNpcId: 'npc_julia', requiredItemType: 'oil', requiredItemId: OIL_ORANGE, description: `Entregue o [√ìleo de ${getOilDisplayName(OIL_ORANGE)}] para [Julia] [E].` },

             // Rafael's Mission (Focus - Rosemary Oil)
            { id: 'p21_find_rafael', type: 'find_npc', targetNpcId: 'npc_rafael', description: "[Rafael] est√° perto da bancada, tentando estudar. Fale com ele [E]." },
            { id: 'p22_rafael_needs_oil', type: 'npc_dialogue', targetNpcId: 'npc_rafael', requiredDialogue: 'initial', description: "Rafael precisa de [foco para estudar]. O [√ìleo Essencial de Alecrim üíß] √© indicado." },
            { id: 'p23_collect_alecrim', type: 'collect_or_deposit', item: 'alecrim', amount: 5, description: "Consiga [5 Alecrins üå±] (na bancada) para o √≥leo de Rafael." },
            { id: 'p24_collect_wood_rafael', type: 'collect_or_deposit', item: 'wood', amount: WOOD_FOR_OIL, description: `Colete mais [${WOOD_FOR_OIL} Lenhas ü™µ] para a fogueira.` }, // NEW: Collect wood
            { id: 'p25_extract_rosemary', type: 'extract_oil', targetOilId: OIL_ROSEMARY, requiresPlantIds: ['alecrim'], plantAmount: 5, requiresWoodAmount: WOOD_FOR_OIL, description: `Use a [Fogueira üî• [G]] para extrair o √ìleo Essencial de [${getOilDisplayName(OIL_ROSEMARY)}].` }, // MODIFIED: Extract at firepit
            { id: 'p26_deliver_oil_rafael', type: 'deliver_item_to_npc', targetNpcId: 'npc_rafael', requiredItemType: 'oil', requiredItemId: OIL_ROSEMARY, description: `Entregue o [√ìleo de ${getOilDisplayName(OIL_ROSEMARY)}] para [Rafael] [E].` },

            // Conclusion
            { id: 'm27_final', type: 'message', description: "Parab√©ns, Mestre Herbalista! Voc√™ ajudou a todos com seu conhecimento de plantas medicinais e √≥leos essenciais!" },
        ];

        // --- Object Creation ---
        const plantMeshes = [];
        const woodMeshes = []; // NEW: Array for wood meshes
        const npcMeshes = [];
        const interactiveObjects = []; // Plants, Wood, Bench, Firepit, NPCs, Bee (Water Source VISUAL ONLY)
        let craftingBenchMesh = null;
        let firepitMesh = null; // NEW: Firepit mesh reference
        let waterSourceMesh = null; // Still used for position reference
        let waterResourceMesh = null; // The collectible sphere
        let bee = null;
        const plantLabelsContainer = document.getElementById('plant-labels-container');
        const plantLabelElements = {}; // Also used for wood labels
        const inventoryListEl = document.getElementById('inventory-list');
        const benchInventoryListEl = document.getElementById('bench-inventory-list');

        // --- Create Water Source Visual & Resource ---
        function createWaterSource() { /* ... unchanged ... */
            const sourceGroup = new THREE.Group();
            const baseGeo = new THREE.CylinderGeometry(0.8, 1, 0.3, 12);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.6 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.receiveShadow = true;
            sourceGroup.add(base);

            const waterGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.15, 12);
            const waterMat = new THREE.MeshStandardMaterial({ color: 0x64b5f6, transparent: true, opacity: 0.85, roughness: 0.2, metalness: 0.1 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.position.y = 0.08;
            sourceGroup.add(water);

            sourceGroup.position.set(5, 0.15, 2);
            // UserData for FIND mission, but NOT added to interactiveObjects
            sourceGroup.userData = { type: 'water_source', id: 'water_source', name: 'Fonte de √Ågua (Visual)' };
            scene.add(sourceGroup);
            return sourceGroup; // Return reference to position the resource
        }
        function createWaterResourceMesh(sourcePosition) { /* ... unchanged ... */
            const resourceGeo = new THREE.SphereGeometry(0.25, 16, 12);
            const resourceMat = new THREE.MeshStandardMaterial({
                color: 0x64b5f6, // Blue
                transparent: true,
                opacity: 0.75,
                emissive: 0x88ccff, // Slight glow
                emissiveIntensity: 0.4,
                roughness: 0.1,
                metalness: 0.2
            });
            const resourceMesh = new THREE.Mesh(resourceGeo, resourceMat);
            // Position above the source base
            resourceMesh.position.copy(sourcePosition).add(new THREE.Vector3(0, 0.8, 0)); // Adjust Y as needed
            resourceMesh.visible = false; // Start invisible
            resourceMesh.userData = { type: 'water_resource', id: 'water_resource_collectible' }; // Identify it
            scene.add(resourceMesh);
            return resourceMesh;
        }


        // --- Plant Creation & Positioning ---
        const plantsPerGroup = {};
        plantasData.forEach(data => { /* ... unchanged positioning & label creation ... */
            const groupInfo = plantGroups[data.group]; if (!groupInfo) { data.position = new THREE.Vector3((Math.random() - 0.5) * 20, 0, (Math.random() - 0.5) * 20); } else { plantsPerGroup[data.group] = (plantsPerGroup[data.group] || 0) + 1; const angleOffset = (plantsPerGroup[data.group] * (Math.PI / 3.5 + Math.random() * 0.3)); const distanceOffset = 2.5 + (plantsPerGroup[data.group] * 0.8); data.position = new THREE.Vector3( groupInfo.position.x + Math.cos(angleOffset) * distanceOffset, 0, groupInfo.position.z + Math.sin(angleOffset) * distanceOffset ); }
            const plantMesh = createPlantMesh(data);
            plantMesh.userData.isCollected = false; plantMesh.userData.respawnTimer = 0;
            plantMeshes.push(plantMesh); interactiveObjects.push(plantMesh); // Plants ARE interactive
            const label = document.createElement('span'); label.textContent = data.name; label.className = 'plant-label'; plantLabelsContainer.appendChild(label); plantLabelElements[data.id] = label; plantMesh.userData.labelElement = label;
        });

        // --- createPlantMesh & Shape Functions ---
        // (Identical functions createPlantMesh, createBush, etc. from previous version)
        function createPlantMesh(data) { /* ... unchanged ... */
            const plantGroup = new THREE.Group(); plantGroup.position.copy(data.position); const stemHeight = Math.random() * 0.5 + 0.6; const stemGeo = new THREE.CylinderGeometry(0.04, 0.06, stemHeight, 6); const stemMat = new THREE.MeshStandardMaterial({ color: data.stemColor || 0x8B4513, roughness: 0.9 }); const stem = new THREE.Mesh(stemGeo, stemMat); stem.position.y = stemHeight / 2; stem.castShadow = true; plantGroup.add(stem); const topMaterial = new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.7, metalness: 0.1 }); let topShape;
            switch (data.shape) { case 'flower': topShape = new THREE.Mesh(new THREE.SphereGeometry(0.3, 12, 8), topMaterial); break; case 'bush': topShape = createBush(topMaterial, stemHeight); break; case 'tall_flower': topShape = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.6, 8), topMaterial); break; case 'rosemary': topShape = createRosemary(topMaterial, stemHeight); break; case 'large_leaf_bush': topShape = createLargeLeafBush(topMaterial, stemHeight); break; case 'aloe': topShape = createAloe(topMaterial, stemHeight); break; case 'flower_orange': topShape = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 8), new THREE.MeshStandardMaterial({ color: 0xFF9800 })); break; case 'flower_yellow': topShape = new THREE.Mesh(new THREE.SphereGeometry(0.3, 12, 8), new THREE.MeshStandardMaterial({ color: 0xffc107 })); break; case 'flower_pink': topShape = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 8), new THREE.MeshStandardMaterial({ color: 0x9575cd })); break; case 'vine_flower': topShape = createVineFlower(topMaterial, stemHeight); break; case 'tall_thin': topShape = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6), topMaterial); break; case 'spiky_bush': topShape = createSpikyBush(topMaterial, stemHeight); break; case 'vine_leaf': topShape = createVineLeaf(topMaterial, stemHeight); break; case 'tall_tree_like': topShape = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.5, 8), topMaterial); break; case 'bush_round': topShape = new THREE.Mesh(new THREE.SphereGeometry(0.45, 10, 8), topMaterial); break; case 'bush_grey': topShape = new THREE.Mesh(new THREE.IcosahedronGeometry(0.4, 0), new THREE.MeshStandardMaterial({ color: 0x9e9e9e, roughness: 0.8 })); break; case 'low_spiky': topShape = createLowSpiky(topMaterial, stemHeight); break; case 'artichoke_like': topShape = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 0), topMaterial); break; case 'bush_round_orange': topShape = createBush(new THREE.MeshStandardMaterial({ color: 0xFF9800 }), stemHeight, 0.5); break; case 'tall_thin_bushy': topShape = createTallThinBushy(topMaterial, stemHeight); break; default: console.warn(`Forma desconhecida: ${data.shape}...`); topShape = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 8), topMaterial); break; }
            if (topShape) { if (!(topShape instanceof THREE.Group)) { const geometryParams = topShape.geometry.parameters; let shapeHeight = 0.3; if (geometryParams) { if (geometryParams.height) shapeHeight = geometryParams.height; else if (geometryParams.radius) shapeHeight = geometryParams.radius * 2; } topShape.position.y = stemHeight + shapeHeight * 0.4; } else { topShape.position.y = stemHeight * 0.1; } topShape.castShadow = true; topShape.traverse(child => { if (child.isMesh) child.castShadow = true; }); plantGroup.add(topShape); }
            plantGroup.userData = { ...data, type: 'plant' }; scene.add(plantGroup); return plantGroup;
        }
        function createBush(material, stemH, scale = 0.4){ const g=new THREE.Group(); for(let i=0; i<7; i++){ const sphereGeo = new THREE.SphereGeometry(Math.random()*0.15+0.1, 8, 6); const sphere = new THREE.Mesh(sphereGeo, material); sphere.position.set((Math.random()-0.5)*scale, stemH+(Math.random()-0.4)*scale*1.2, (Math.random()-0.5)*scale); sphere.castShadow=true; g.add(sphere); } return g; }
        function createRosemary(m,h){ const g=new THREE.Group(); for(let i=0;i<12;i++){const lG=new THREE.CylinderGeometry(0.02,0.02,0.6,5);const l=new THREE.Mesh(lG,m); l.position.set((Math.random()-0.5)*0.15, h+(Math.random())*0.5, (Math.random()-0.5)*0.15); l.rotation.x=(Math.random()-0.5)*Math.PI/1.2; l.rotation.z=(Math.random()-0.5)*Math.PI/1.2; l.castShadow=true;g.add(l);} return g; }
        function createLargeLeafBush(m,h){ const g=new THREE.Group(); for(let i=0;i<6;i++){ const lG=new THREE.PlaneGeometry(0.6,0.8); const l=new THREE.Mesh(lG,m.clone()); l.material.side=THREE.DoubleSide; l.position.set((Math.random()-0.5)*0.5, h+(Math.random())*0.6, (Math.random()-0.5)*0.5); l.rotation.x=Math.random()*Math.PI*0.2; l.rotation.y=Math.random()*Math.PI; l.rotation.z=(Math.random()-0.5)*Math.PI*0.2; l.castShadow=true; g.add(l);} return g;}
        function createAloe(m,h){ const g=new THREE.Group(); for(let i=0;i<8;i++){ const lG=new THREE.CylinderGeometry(0.03,0.12,0.9,5); const l=new THREE.Mesh(lG,m); l.position.y=h*0.7; l.rotation.z=(Math.random()-0.5)*0.4; l.rotation.x=Math.PI/2.4+(Math.random()-0.5)*0.2; l.rotateY(i*(Math.PI*2/8)); l.castShadow=true; g.add(l);} return g;}
        function createVineFlower(m,h){ const g=new THREE.Group(); const k=new THREE.Mesh(new THREE.TorusKnotGeometry(0.25,0.06,60,8),m); k.position.y=h+0.25; k.castShadow=true; g.add(k); return g; }
        function createSpikyBush(m,h){ const g=new THREE.Group(); const i=new THREE.Mesh(new THREE.IcosahedronGeometry(0.45, 0), m); i.position.y=h+0.25; i.castShadow=true; g.add(i); return g; }
        function createVineLeaf(m,h){ return createLargeLeafBush(m,h); }
        function createLowSpiky(m,h){ const g=new THREE.Group(); const t=new THREE.Mesh(new THREE.TetrahedronGeometry(0.45,0), m); t.position.y=h+0.25; t.castShadow=true; g.add(t); return g; }
        function createTallThinBushy(material, stemH) { /* ... unchanged ... */
            const group = new THREE.Group(); const numStalks = 5 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numStalks; i++) { const stalkHeight = 0.8 + Math.random() * 0.5; const stalkGeo = new THREE.CylinderGeometry(0.03, 0.04, stalkHeight, 5); const stalk = new THREE.Mesh(stalkGeo, material); const angle = (i / numStalks) * Math.PI * 2; const radius = 0.1 + Math.random() * 0.1; stalk.position.set(Math.cos(angle) * radius, stemH + stalkHeight * 0.5 - 0.1, Math.sin(angle) * radius); stalk.rotation.x = (Math.random() - 0.5) * 0.2; stalk.rotation.z = (Math.random() - 0.5) * 0.2; stalk.castShadow = true; group.add(stalk);
                for (let j = 0; j < 3; j++) { const leafGeo = new THREE.BoxGeometry(0.02, 0.2, 0.02); const leaf = new THREE.Mesh(leafGeo, material); leaf.position.y = Math.random() * stalkHeight * 0.6 + stalkHeight * 0.2; leaf.position.x = (Math.random() - 0.5) * 0.1; leaf.position.z = (Math.random() - 0.5) * 0.1; leaf.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); stalk.add(leaf); }
             } return group;
        }

        // NEW: Wood Creation
        function createWoodMesh(data) {
            const woodGroup = new THREE.Group();
            const logMaterial = new THREE.MeshStandardMaterial({ color: data.color || 0x8D6E63, roughness: 0.9 });
            const logGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 6);

            // Create a small pile of logs
            const log1 = new THREE.Mesh(logGeo, logMaterial);
            log1.rotation.z = Math.PI / 2;
            log1.rotation.y = Math.random() * 0.5;
            log1.position.y = 0.1;
            log1.castShadow = true;
            woodGroup.add(log1);

            const log2 = new THREE.Mesh(logGeo, logMaterial);
            log2.rotation.z = Math.PI / 2;
            log2.rotation.y = Math.random() * 0.5 - 0.2;
            log2.position.set(0.05, 0.1, 0.15);
            log2.castShadow = true;
            woodGroup.add(log2);

            const log3 = new THREE.Mesh(logGeo, logMaterial);
            log3.rotation.z = Math.PI / 2;
            log3.rotation.y = Math.random() * 0.5 + 0.1;
            log3.position.set(-0.05, 0.25, 0.08);
            log3.castShadow = true;
            woodGroup.add(log3);

            woodGroup.position.copy(data.position);
            woodGroup.userData = { ...data, type: 'wood' }; // Set type to 'wood'
            scene.add(woodGroup);
            return woodGroup;
        }

        // --- Crafting Bench, Firepit & Bee Creation ---
        function createCraftingBench() { /* ... unchanged ... */
             const benchGroup = new THREE.Group(); const benchMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 }); const topGeo = new THREE.BoxGeometry(2.5, 0.2, 1.2); const topMesh = new THREE.Mesh(topGeo, benchMaterial); topMesh.position.y = 0.8; topMesh.castShadow = true; topMesh.receiveShadow = true; benchGroup.add(topMesh); const legGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2); const legPositions = [ { x: -1.0, z: -0.4 }, { x: 1.0, z: -0.4 }, { x: -1.0, z: 0.4 }, { x: 1.0, z: 0.4 } ]; legPositions.forEach(pos => { const legMesh = new THREE.Mesh(legGeo, benchMaterial); legMesh.position.set(pos.x, 0.4, pos.z); legMesh.castShadow = true; benchGroup.add(legMesh); }); const bottleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8); const bottleMat = new THREE.MeshStandardMaterial({ color: 0xa0a0ff, transparent: true, opacity: 0.6 }); const bottle1 = new THREE.Mesh(bottleGeo, bottleMat); bottle1.position.set(-0.8, 0.8 + 0.1, 0.3); bottle1.castShadow = true; benchGroup.add(bottle1); const bottle2 = bottle1.clone(); bottle2.position.set(-0.6, 0.8 + 0.1, 0.35); benchGroup.add(bottle2);
             benchGroup.position.set(0, 0, 3); benchGroup.userData = { type: 'crafting_bench', id: 'crafting_bench', name: 'Bancada de Preparo' }; scene.add(benchGroup); interactiveObjects.push(benchGroup); return benchGroup; // Bench IS interactive
        }

        // NEW: Create Firepit
        function createFirepitMesh() {
            const firepitGroup = new THREE.Group();
            const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x78909C, roughness: 0.85 });
            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x6D4C41, roughness: 0.9 });
            const fireMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 }); // Simple fire glow

            // Stones around
            const stoneGeo = new THREE.BoxGeometry(0.3, 0.25, 0.3);
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = 0.6;
                const stone = new THREE.Mesh(stoneGeo, stoneMaterial);
                stone.position.set(Math.cos(angle) * radius, 0.125, Math.sin(angle) * radius);
                stone.rotation.y = -angle + Math.random() * 0.4 - 0.2;
                stone.castShadow = true;
                firepitGroup.add(stone);
            }

            // Wood inside (simple logs)
            const logGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 5);
            const log1 = new THREE.Mesh(logGeo, woodMaterial);
            log1.rotation.set(0, 0, Math.PI / 2.5);
            log1.position.set(0, 0.1, 0.1);
            log1.castShadow = true;
            firepitGroup.add(log1);
            const log2 = new THREE.Mesh(logGeo, woodMaterial);
            log2.rotation.set(0, 0, -Math.PI / 2.2);
            log2.position.set(0.1, 0.15, -0.1);
            log2.castShadow = true;
            firepitGroup.add(log2);

            // Fire glow (optional simple sphere)
            const fireGeo = new THREE.SphereGeometry(0.3, 12, 8);
            const fire = new THREE.Mesh(fireGeo, fireMaterial);
            fire.position.y = 0.2;
            // Add point light for better effect (optional)
            const fireLight = new THREE.PointLight(0xffaa33, 0.8, 3);
            fireLight.position.y = 0.4;
            fire.add(fireLight); // Attach light to the glow mesh
            firepitGroup.add(fire);


            firepitGroup.position.set(4, 0, -2); // Position near water source?
            firepitGroup.userData = { type: 'firepit', id: 'firepit', name: 'Fogueira' };
            scene.add(firepitGroup);
            interactiveObjects.push(firepitGroup); // Firepit IS interactive
            return firepitGroup;
        }

        function createBee() { /* ... unchanged ... */
             const beeGroup = new THREE.Group(); const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffcc00 }); const blackMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); const wingMat = new THREE.MeshStandardMaterial({ color: 0xddddff, transparent: true, opacity: 0.7 }); const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.18, 0.18), bodyMat); beeGroup.add(body); const head = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.12), blackMat); head.position.set(-0.21, 0, 0); beeGroup.add(head); const wing1 = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.18, 0.36), wingMat); wing1.position.set(0.06, 0.15, 0); beeGroup.add(wing1); const wing2 = wing1.clone(); wing2.position.set(-0.06, 0.15, 0); beeGroup.add(wing2); beeGroup.position.set(10, 1.5, -4); beeGroup.userData = { type: 'bee_link', id: 'bee', name: 'Abelha', url: 'https://edaraujofilho.criadorlw.com.br/aula10pics' }; scene.add(beeGroup); interactiveObjects.push(beeGroup); return beeGroup; // Bee IS interactive
        }

        // --- NPC Creation ---
        function createNPCMesh(data) { /* ... unchanged ... */
            const npcGroup = new THREE.Group(); const bodyGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8); const bodyMat = new THREE.MeshStandardMaterial({ color: data.color || 0xcccccc, roughness: 0.8 }); const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.y = 0.6; body.castShadow = true; npcGroup.add(body); const headGeo = new THREE.SphereGeometry(0.3, 16, 16); const headMat = new THREE.MeshStandardMaterial({ color: data.color ? new THREE.Color(data.color).offsetHSL(0, 0, -0.2) : 0xaaaaaa, roughness: 0.7 }); const head = new THREE.Mesh(headGeo, headMat); head.position.y = 1.2 + 0.3; head.castShadow = true; npcGroup.add(head); npcGroup.position.copy(data.position); npcGroup.userData = { ...data, type: 'npc' }; scene.add(npcGroup); interactiveObjects.push(npcGroup); return npcGroup; // NPCs ARE interactive
        }
        npcsData.forEach(npcData => { npcMeshes.push(createNPCMesh(npcData)); });

        // NEW: Create Wood Piles
        woodData.forEach(data => {
             const woodMesh = createWoodMesh(data);
             woodMesh.userData.isCollected = false;
             woodMesh.userData.respawnTimer = 0;
             woodMeshes.push(woodMesh);
             interactiveObjects.push(woodMesh); // Wood IS interactive

             // Create label for wood (similar to plants)
             const label = document.createElement('span');
             label.textContent = data.name;
             label.className = 'plant-label'; // Reuse plant label style
             plantLabelsContainer.appendChild(label);
             plantLabelElements[data.id] = label;
             woodMesh.userData.labelElement = label;
        });


        // --- Controls Setup & Logic ---
        const orbitControls = new THREE.OrbitControls(camera, renderer.domElement); /* ... unchanged settings ... */
        orbitControls.enableDamping = true; orbitControls.dampingFactor = 0.07; orbitControls.screenSpacePanning = false; orbitControls.minDistance = 1; orbitControls.maxDistance = 50; orbitControls.maxPolarAngle = Math.PI / 2.05; orbitControls.target.set(0, 0.5, 0); orbitControls.enabled = (currentControlsMode === 'orbit');

        const pointerLockControls = new THREE.PointerLockControls(camera, document.body); /* ... unchanged setup ... */
        scene.add(pointerLockControls.getObject());

        const controlsToggleButton = document.getElementById('controls-toggle'); /* ... unchanged UI elements ... */
        const instructionsEl = document.getElementById('instructions');
        const interactionPromptEl = document.getElementById('interaction-prompt');

        pointerLockControls.addEventListener('lock', () => { /* ... unchanged Lock logic ... */ console.log("Pointer Locked"); canvasContainer.classList.add('pointer-locked'); controlsToggleButton.style.display = 'none'; instructionsEl.style.bottom = '20px'; interactionPromptEl.style.display = 'none'; pointerLockControls.getObject().position.y = 1.6; });
        pointerLockControls.addEventListener('unlock', () => { /* ... unchanged Unlock logic ... */ console.log("Pointer Unlocked"); canvasContainer.classList.remove('pointer-locked'); currentControlsMode = 'orbit'; orbitControls.enabled = true; controlsToggleButton.style.display = 'block'; controlsToggleButton.textContent = 'Ativar Vis√£o Pessoal'; interactionPromptEl.classList.remove('visible'); instructionsEl.style.bottom = '70px'; moveState.forward = false; moveState.backward = false; moveState.left = false; moveState.right = false; velocity.set(0,0,0); });
        controlsToggleButton.addEventListener('click', () => { /* ... unchanged Toggle logic ... */
             if (currentControlsMode === 'orbit') { orbitControls.enabled = false; const currentTarget = orbitControls.target.clone(); if (currentTarget.y < 0.5) { currentTarget.y = 0.5; } const offsetDirection = camera.position.clone().sub(orbitControls.target).normalize(); offsetDirection.y = 0; offsetDirection.normalize(); const desiredPosition = currentTarget.clone().add(offsetDirection.multiplyScalar(2)); desiredPosition.y = 1.6; camera.position.copy(desiredPosition); pointerLockControls.getObject().position.copy(desiredPosition); const lookAtPoint = orbitControls.target.clone(); lookAtPoint.y = 1.6; camera.lookAt(lookAtPoint); pointerLockControls.lock(); currentControlsMode = 'fpv'; }
        });

        // --- FPV Movement State & Keys ---
        const moveState = { forward: false, backward: false, left: false, right: false }; /* ... unchanged moveState, moveSpeed, velocity, direction ... */
        const moveSpeed = 4.5;
        const velocity = new THREE.Vector3(); const direction = new THREE.Vector3();

        const onKeyDown = (event) => { /* ... onKeyDown listener (Updated F & G) ... */
            if (!pointerLockControls.isLocked && currentControlsMode === 'fpv') return;
            switch (event.code) {
                 case 'ArrowUp': case 'KeyW': moveState.forward = true; break;
                 case 'ArrowLeft': case 'KeyA': moveState.left = true; break;
                 case 'ArrowDown': case 'KeyS': moveState.backward = true; break;
                 case 'ArrowRight': case 'KeyD': moveState.right = true; break;
                 case 'KeyE': if(pointerLockControls.isLocked) interactInfoOrNPC(); break; // E for Info (Plant/Wood) or Talk (NPC)
                 case 'KeyF': if(pointerLockControls.isLocked) interactActionOrDeposit(); break; // F for Collect Plant/Wood, Bee OR Deposit (Bench)
                 case 'KeyG': if(pointerLockControls.isLocked) interactCraftExtract(); break; // G for Craft(Bench)/Extract(Firepit)
            }
        };
        const onKeyUp = (event) => { /* ... unchanged onKeyUp listener ... */
             if (!pointerLockControls.isLocked && currentControlsMode === 'fpv') return;
             switch (event.code) {
                 case 'ArrowUp': case 'KeyW': moveState.forward = false; break;
                 case 'ArrowLeft': case 'KeyA': moveState.left = false; break;
                 case 'ArrowDown': case 'KeyS': moveState.backward = false; break;
                 case 'ArrowRight': case 'KeyD': moveState.right = false; break;
             }
        };
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);

        // --- Raycasting, Interaction & UI Refs ---
        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); const centerScreen = new THREE.Vector2(0, 0); /* ... unchanged UI element refs ... */
        const infoPanel = document.getElementById('info-panel'); const plantNameEl = document.getElementById('plant-name'); const plantGroupEl = document.getElementById('plant-group'); const plantBenefitsEl = document.getElementById('plant-benefits'); const plantLinkEl = document.getElementById('plant-link'); const closeInfoButton = document.getElementById('close-info');
        const missionPanel = document.getElementById('mission-panel'); const currentMissionEl = document.getElementById('current-mission'); const knowledgeBaseEl = document.getElementById('knowledge-base').querySelector('ul'); const craftedItemsEl = document.getElementById('crafted-items').querySelector('ul'); const extractedOilsEl = document.getElementById('extracted-oils').querySelector('ul'); const statusMessageEl = document.getElementById('status-message');
        const beeBalloon = document.getElementById('bee-balloon');
        let isAnimatingCamera = false; const interactionDistance = 4.0; /* ... unchanged interaction state vars ... */
        let objectInFocus = null; let canInteractWithFocus = false;
        const tempVector = new THREE.Vector3(); const labelMaxDistance = 18;


        // --- Interaction Functions ---

        function getPlayerPlantCount() { /* ... unchanged ... */ let count = 0; for (const itemId in gameState.inventory) { if (itemId !== 'water' && itemId !== 'wood' && gameState.inventory[itemId] > 0) { count++; } } return count; }
        function getPlayerWoodCount() { /* NEW */ return gameState.inventory.wood || 0; }

        function onMouseClick(event) { /* ... onMouseClick (Added wood & firepit cases) ... */
            if (currentControlsMode !== 'orbit' || isAnimatingCamera || infoPanel.contains(event.target)) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(interactiveObjects, true); // Only check INTERACTIVE objects

            let clickedSomethingInteractive = false;
            if (intersects.length > 0) {
                const clickedRoot = getRootInteractiveObject(intersects[0].object);
                if (clickedRoot && clickedRoot.userData.id) {
                    clickedSomethingInteractive = true;
                    objectInFocus = clickedRoot;
                    const ud = clickedRoot.userData;
                    console.log("Orbit Clicked:", ud.type, ud.id);

                    if ((ud.type === 'plant' || ud.type === 'wood') && !ud.isCollected) { // Combined plant/wood info
                        focusOnPlant(clickedRoot); showInfoPanel(ud, true);
                    } else if (ud.type === 'npc') {
                        focusOnPlant(clickedRoot, 1.8, 4.0); interactWithNPC(clickedRoot);
                    } else if (ud.type === 'crafting_bench') {
                        focusOnPlant(clickedRoot, 1.0, 4.0); interactActionOrDeposit(); // May trigger deposit prompt or just focus
                    } else if (ud.type === 'firepit') { // NEW: Click on firepit
                        focusOnPlant(clickedRoot, 1.0, 4.0); interactCraftExtract(); // Try to use it
                    } else if (ud.type === 'bee_link') {
                        focusOnPlant(clickedRoot, 1.5, 3.0); interactActionOrDeposit(); // Opens link
                    }
                    // No specific action for clicking water source base anymore
                }
            }

            if (!clickedSomethingInteractive) {
                hideInfoPanel(); objectInFocus = null;
            }
        }

        function handleFocusRaycast() { /* ... handleFocusRaycast (Updated for wood & firepit) ... */
             if (!pointerLockControls.isLocked) return;
             raycaster.setFromCamera(centerScreen, camera);
             const intersects = raycaster.intersectObjects(interactiveObjects, true); // Only check INTERACTIVE objects
             objectInFocus = null;
             canInteractWithFocus = false;
             interactionPromptEl.classList.remove('visible');

             if (intersects.length > 0 && intersects[0].distance <= interactionDistance) {
                 const focusedRoot = getRootInteractiveObject(intersects[0].object);
                 if (focusedRoot && focusedRoot.userData.id) {
                     objectInFocus = focusedRoot;
                     const ud = objectInFocus.userData;
                     interactionPromptEl.classList.add('visible');

                     if (ud.type === 'plant') {
                         if (!ud.isCollected) {
                             interactionPromptEl.textContent = `[E] Ver ${ud.name}`;
                             canInteractWithFocus = true;
                             if (gameState.canCollectPlant) {
                                 interactionPromptEl.textContent += ` / [F] Coletar`;
                             }
                         } else {
                             interactionPromptEl.textContent = `${ud.name} (Coletado)`;
                         }
                     } else if (ud.type === 'wood') { // NEW: Wood interaction
                         if (!ud.isCollected) {
                             interactionPromptEl.textContent = `[E] Ver ${ud.name}`;
                             canInteractWithFocus = true;
                             if (gameState.canCollectWood) {
                                 interactionPromptEl.textContent += ` / [F] Coletar`;
                             }
                         } else {
                             interactionPromptEl.textContent = `${ud.name} (Coletado)`;
                         }
                     } else if (ud.type === 'crafting_bench') {
                         const carryingPlants = getPlayerPlantCount() > 0;
                         let benchInteractable = false;
                         if (carryingPlants) {
                             interactionPromptEl.textContent = `[F] Depositar Plantas`;
                             benchInteractable = true;
                             if (gameState.canCraftPhyto) {
                                 interactionPromptEl.textContent += ` / [G] Usar (Ch√°)`;
                             }
                         } else if (gameState.canCraftPhyto) {
                             interactionPromptEl.textContent = `[G] Usar Bancada (Ch√°)`;
                             benchInteractable = true;
                         } else {
                             interactionPromptEl.textContent = `Bancada de Preparo`;
                         }
                         canInteractWithFocus = benchInteractable;
                     } else if (ud.type === 'firepit') { // NEW: Firepit interaction
                         if (gameState.canExtractOil) {
                             interactionPromptEl.textContent = `[G] Usar Fogueira (√ìleo)`;
                             canInteractWithFocus = true;
                         } else {
                             interactionPromptEl.textContent = `Fogueira`;
                         }
                     } else if (ud.type === 'npc') {
                         interactionPromptEl.textContent = `[E] Falar com ${ud.name}`;
                         canInteractWithFocus = true;
                     } else if (ud.type === 'bee_link') {
                         interactionPromptEl.textContent = `[F] Ver Abelhas`;
                         canInteractWithFocus = true;
                     } else {
                         interactionPromptEl.classList.remove('visible'); // Hide if unknown interactive type
                     }

                     if (!canInteractWithFocus && interactionPromptEl.textContent === "Pressione [E] para Interagir") {
                          interactionPromptEl.classList.remove('visible'); // Clean up default prompt if not interactive
                     }

                 } else {
                      interactionPromptEl.classList.remove('visible');
                 }
             } else {
                  interactionPromptEl.classList.remove('visible');
             }
        }

        function interactInfoOrNPC() { /* ... interactInfoOrNPC (Added wood info) ... */
            if (!objectInFocus || !canInteractWithFocus || !pointerLockControls.isLocked) return;
            const ud = objectInFocus.userData;
            if ((ud.type === 'plant' || ud.type === 'wood') && !ud.isCollected) { // Show info for plants or wood
                showInfoPanel(ud, true);
            } else if (ud.type === 'npc') {
                interactWithNPC(objectInFocus);
            }
        }

        // MODIFIED interactActionOrDeposit (Added wood collection)
        function interactActionOrDeposit() {
             if (!objectInFocus || !canInteractWithFocus) return;
             if (currentControlsMode === 'fpv' && !pointerLockControls.isLocked) return;

             const ud = objectInFocus.userData;
             console.log("Action/Deposit triggered on:", ud.type, ud.id);

             if (ud.type === 'plant' && gameState.canCollectPlant && !ud.isCollected) {
                 collectPlant(objectInFocus);
             } else if (ud.type === 'wood' && gameState.canCollectWood && !ud.isCollected) { // NEW: Collect wood
                 collectWood(objectInFocus);
             } else if (ud.type === 'crafting_bench' && getPlayerPlantCount() > 0) {
                 depositPlantsToBench(); // 'F' at bench with plants = deposit
             } else if (ud.type === 'bee_link') {
                 window.open(ud.url, '_blank');
                 updateStatus("Visitando o mundo das abelhas...", 'info');
             }
        }

        function interactCraftExtract() { /* ... interactCraftExtract (Handles both bench and firepit) ... */
            if (!objectInFocus || !canInteractWithFocus || !pointerLockControls.isLocked) return;
            const ud = objectInFocus.userData;
            if (ud.type === 'crafting_bench') {
                console.log("Craft attempt at bench...");
                tryCraftingPhyto(); // Only phyto at bench now
            } else if (ud.type === 'firepit') { // NEW: Firepit interaction
                console.log("Extract attempt at firepit...");
                tryExtractingOil();
            }
        }

        function collectPlant(plantMesh) { /* ... collectPlant (Added check for plant inventory) ... */
            if (!plantMesh || !plantMesh.userData || plantMesh.userData.isCollected || !gameState.canCollectPlant) { console.warn("Cannot collect plant:", plantMesh?.userData?.id); return; }
            if (getPlayerPlantCount() >= MAX_PLAYER_PLANT_INVENTORY) {
                updateStatus(`Invent√°rio de plantas cheio (${MAX_PLAYER_PLANT_INVENTORY}/${MAX_PLAYER_PLANT_INVENTORY})! Deposite na bancada [F].`, 'error');
                return;
            }
            const ud = plantMesh.userData;
            const plantId = ud.id;
            gameState.inventory[plantId] = (gameState.inventory[plantId] || 0) + 1;
            ud.isCollected = true;
            ud.respawnTimer = PLANT_RESPAWN_TIME;
            plantMesh.visible = false;
            if (ud.labelElement) ud.labelElement.classList.remove('visible', 'pulsing');
            updateStatus(`${ud.name} coletado(a)!`, 'success');
            updateInventoryUI();
            hideInfoPanel();
            interactionPromptEl.classList.remove('visible');
            checkMissionCompletion();
        }

        // NEW: Collect Wood
        function collectWood(woodMesh) {
            if (!woodMesh || !woodMesh.userData || woodMesh.userData.isCollected || !gameState.canCollectWood) { console.warn("Cannot collect wood:", woodMesh?.userData?.id); return; }
            if (getPlayerWoodCount() >= MAX_PLAYER_WOOD_INVENTORY) {
                updateStatus(`Invent√°rio de lenha cheio (${MAX_PLAYER_WOOD_INVENTORY}/${MAX_PLAYER_WOOD_INVENTORY})!`, 'error');
                return;
            }
            const ud = woodMesh.userData;
            gameState.inventory.wood = (gameState.inventory.wood || 0) + 1; // Add to 'wood' key
            ud.isCollected = true;
            ud.respawnTimer = WOOD_RESPAWN_TIME;
            woodMesh.visible = false;
            if (ud.labelElement) ud.labelElement.classList.remove('visible', 'pulsing');
            updateStatus(`${ud.name} coletada!`, 'success');
            updateInventoryUI();
            hideInfoPanel();
            interactionPromptEl.classList.remove('visible');
            checkMissionCompletion();
        }


        // Function remains, but called automatically now
        function collectWater() { /* ... unchanged ... */
            // No need to check canCollectWater anymore, triggered by proximity/availability
            gameState.inventory.water = (gameState.inventory.water || 0) + WATER_COLLECT_AMOUNT;
            updateStatus(`Voc√™ coletou ${WATER_COLLECT_AMOUNT} unidades de √Ågua!`, 'success');
            updateInventoryUI();
            checkMissionCompletion(); // Check if collecting water completes a mission
        }

        function depositPlantsToBench() { /* ... unchanged ... */
            if (!objectInFocus || objectInFocus.userData.type !== 'crafting_bench') return;
            let depositedCount = 0;
            for (const itemId in gameState.inventory) {
                // Only deposit plants, not water or wood
                if (itemId !== 'water' && itemId !== 'wood' && gameState.inventory[itemId] > 0) {
                    const count = gameState.inventory[itemId];
                    gameState.benchInventory[itemId] = (gameState.benchInventory[itemId] || 0) + count;
                    gameState.inventory[itemId] = 0; // Remove from player inventory
                    depositedCount += count;
                    console.log(`Deposited ${count} of ${itemId}`);
                    delete gameState.inventory[itemId]; // Clean up if zero
                }
            }
            if (depositedCount > 0) {
                updateStatus(`${depositedCount} planta(s) depositada(s) na bancada.`, 'success');
                updateInventoryUI();
                checkMissionCompletion();
                handleFocusRaycast(); // Update prompt after depositing
            } else {
                updateStatus("Voc√™ n√£o tem plantas para depositar.", 'info');
            }
        }

        // Renamed and modified: Only handles Phyto crafting at the bench
        function tryCraftingPhyto() {
            console.log("Trying to craft phyto at bench...");
            if (gameState.gameComplete) { updateStatus("Voc√™ j√° ajudou a todos!", 'info'); return; }
            if (!gameState.canCraftPhyto) { updateStatus("Voc√™ ainda n√£o aprendeu a preparar ch√°s.", 'info'); return; }

            const currentMission = missions[gameState.currentMissionIndex];
            if (currentMission && currentMission.type === 'craft_item') {
                const recipeId = currentMission.recipeId;
                const recipe = recipes[recipeId];
                if (!recipe || recipe.type !== 'phyto') {
                    console.warn("Current mission is not a valid phyto recipe or recipe not found:", recipeId);
                    updateStatus("Nenhuma receita de ch√° ativa na miss√£o atual.", 'info');
                    return;
                }
                if (hasIngredients(recipe.ingredients, true)) { // Check bench + player inventory
                    consumeIngredients(recipe.ingredients); // Consume from bench/player
                    gameState.craftedItems[recipeId] = true;
                    updateStatus(`${recipe.name} preparado com sucesso! üçµ`, 'success');
                    updateInventoryUI();
                    updateMissionPanel();
                    checkMissionCompletion();
                } else {
                    updateStatus(`Faltam ingredientes para ${recipe.name}. Verifique a bancada (plantas) e o invent√°rio (√°gua).`, 'error');
                }
            } else {
                updateStatus("Use a bancada [G] para preparar o ch√° da miss√£o atual.", 'info');
            }
        }

        // NEW: Handles Oil extraction at the firepit
        function tryExtractingOil() {
            console.log("Trying to extract oil at firepit...");
            if (gameState.gameComplete) { updateStatus("Voc√™ j√° ajudou a todos!", 'info'); return; }
            if (!gameState.canExtractOil) { updateStatus("Voc√™ ainda n√£o aprendeu a extrair √≥leos essenciais.", 'info'); return; }

            const currentMission = missions[gameState.currentMissionIndex];
            if (currentMission && currentMission.type === 'extract_oil') {
                const oilId = currentMission.targetOilId;
                const requiredPlantId = currentMission.requiresPlantIds[0]; // Assuming one plant type per oil for now
                const requiredPlantAmount = currentMission.plantAmount || 1;
                const requiredWoodAmount = currentMission.requiresWoodAmount || WOOD_FOR_OIL; // Use mission value or default

                if (gameState.extractedOils[oilId]) {
                    updateStatus(`Voc√™ j√° extraiu o √ìleo de ${getOilDisplayName(oilId)}.`, 'info');
                    checkMissionCompletion(); // Might advance if already done
                    return;
                }

                // Check ingredients: Plants from BENCH, Wood from PLAYER inventory
                const hasRequiredPlants = (gameState.benchInventory[requiredPlantId] || 0) >= requiredPlantAmount;
                const hasRequiredWood = (gameState.inventory.wood || 0) >= requiredWoodAmount;

                if (hasRequiredPlants && hasRequiredWood) {
                    // Consume ingredients
                    gameState.benchInventory[requiredPlantId] -= requiredPlantAmount;
                    if (gameState.benchInventory[requiredPlantId] <= 0) {
                        delete gameState.benchInventory[requiredPlantId];
                    }
                    gameState.inventory.wood -= requiredWoodAmount;
                    if (gameState.inventory.wood <= 0) {
                        gameState.inventory.wood = 0; // Ensure it doesn't go negative
                    }

                    gameState.extractedOils[oilId] = true;
                    updateStatus(`√ìleo Essencial de ${getOilDisplayName(oilId)} extra√≠do na fogueira! üî•üíß`, 'success');
                    updateInventoryUI();
                    updateMissionPanel();
                    checkMissionCompletion();
                } else {
                    let errorMsg = `Faltam ingredientes para extrair o √ìleo de ${getOilDisplayName(oilId)}: `;
                    if (!hasRequiredPlants) errorMsg += `Precisa de ${requiredPlantAmount} ${getItemDisplayName(requiredPlantId)} na bancada. `;
                    if (!hasRequiredWood) errorMsg += `Precisa de ${requiredWoodAmount} Lenha no invent√°rio.`;
                    updateStatus(errorMsg, 'error');
                }
            } else {
                updateStatus("Use a fogueira [G] para extrair o √≥leo essencial da miss√£o atual.", 'info');
            }
        }


        function interactWithNPC(npcMesh) { /* ... unchanged ... */
            if (!npcMesh || !npcMesh.userData || npcMesh.userData.type !== 'npc') return;
            const npcData = npcMesh.userData;
            const npcId = npcData.id;
            console.log("Interacting with NPC:", npcId, npcData.name);
            const currentMission = missions[gameState.currentMissionIndex];
            if (!currentMission) return;

            // Check if current mission involves this NPC
            if ((currentMission.type === 'find_npc' || currentMission.type === 'npc_dialogue' || currentMission.type === 'deliver_item_to_npc') && currentMission.targetNpcId === npcId) {
                // Handle delivery
                if (currentMission.type === 'deliver_item_to_npc') {
                    const reqType = currentMission.requiredItemType;
                    const reqId = currentMission.requiredItemId;
                    let hasItem = false;
                    if (reqType === 'phyto' && gameState.craftedItems[reqId]) {
                        hasItem = true;
                    } else if (reqType === 'oil' && gameState.extractedOils[reqId]) {
                        hasItem = true;
                    }

                    if (hasItem) {
                        updateStatus(`${npcData.name}: "${npcData.dialogue.thanks}"`, 'highlight', true);
                        gameState.npcStates[npcId] = true; // Mark NPC as helped
                        // Item consumption happens in checkMissionCompletion now
                        checkMissionCompletion(); // Trigger mission check immediately after successful interaction
                    } else {
                        updateStatus(`${npcData.name}: "${npcData.dialogue.reminder}"`, 'persistent');
                    }
                }
                // Handle initial dialogue or finding
                else if (currentMission.type === 'find_npc' || currentMission.type === 'npc_dialogue') {
                    updateStatus(`${npcData.name}: "${npcData.dialogue.initial}"`, 'persistent');
                    checkMissionCompletion(); // Check if finding/talking completes the mission
                }
            }
            // Generic interaction if mission doesn't involve this NPC currently
            else {
                if (gameState.npcStates[npcId]) { // If NPC was already helped
                    updateStatus(`${npcData.name}: "Obrigado novamente pela ajuda!"`, 'info');
                } else {
                    updateStatus(`${npcData.name}: "Ol√°! Que dia lindo para estar no jardim."`, 'info');
                }
            }
        }

        // Modified hasIngredients to check bench OR player inventory depending on context
        // 'checkBenchForPlants' flag added: true checks bench first for non-water/wood items
        function hasIngredients(ingredients, checkBenchForPlants = false) {
            for (const itemId in ingredients) {
                const requiredAmount = ingredients[itemId];
                let totalAmount = 0;

                if (itemId === 'water') {
                    totalAmount = (gameState.inventory.water || 0) + (gameState.benchInventory.water || 0); // Water can be anywhere (unlikely on bench)
                } else if (itemId === 'wood') {
                     totalAmount = (gameState.inventory.wood || 0); // Wood assumed to be only in player inventory for crafting/extraction
                } else if (checkBenchForPlants) {
                    // Primarily check bench for plants when crafting phyto
                    totalAmount = (gameState.benchInventory[itemId] || 0) + (gameState.inventory[itemId] || 0);
                } else {
                    // Default: check player inventory first, then bench (e.g., for mission completion check)
                     totalAmount = (gameState.inventory[itemId] || 0) + (gameState.benchInventory[itemId] || 0);
                }


                if (totalAmount < requiredAmount) {
                    console.log(`Ingredient check fail: Need ${requiredAmount} of ${itemId}, have ${totalAmount} total.`);
                    return false;
                }
            }
            return true;
        }

        // Modified consumeIngredients: Prioritizes bench for plants if needed, player for water/wood
        function consumeIngredients(ingredients) {
            console.log("Consuming ingredients:", ingredients);
            for (const itemId in ingredients) {
                let amountNeeded = ingredients[itemId];

                // Prioritize consuming plants from bench if they exist there
                if (itemId !== 'water' && itemId !== 'wood' && gameState.benchInventory[itemId] > 0) {
                    const consumeFromBench = Math.min(amountNeeded, gameState.benchInventory[itemId]);
                    gameState.benchInventory[itemId] -= consumeFromBench;
                    amountNeeded -= consumeFromBench;
                    console.log(`Consumed ${consumeFromBench} of ${itemId} from bench.`);
                    if (gameState.benchInventory[itemId] <= 0) {
                        delete gameState.benchInventory[itemId];
                    }
                }

                // Consume remaining from player inventory (or water/wood primarily from player)
                if (amountNeeded > 0 && gameState.inventory[itemId] > 0) {
                    const consumeFromPlayer = Math.min(amountNeeded, gameState.inventory[itemId]);
                    gameState.inventory[itemId] -= consumeFromPlayer;
                    amountNeeded -= consumeFromPlayer;
                    console.log(`Consumed ${consumeFromPlayer} of ${itemId} from player.`);
                    if (gameState.inventory[itemId] <= 0 && itemId !== 'water' && itemId !== 'wood') {
                        delete gameState.inventory[itemId]; // Remove non-essential items if zero
                    } else if ((itemId === 'water' || itemId === 'wood') && gameState.inventory[itemId] < 0) {
                        gameState.inventory[itemId] = 0; // Ensure water/wood don't go negative
                    }
                }

                // Consume water from bench if necessary (unlikely but possible)
                if (itemId === 'water' && amountNeeded > 0 && gameState.benchInventory.water > 0) {
                     const consumeFromBench = Math.min(amountNeeded, gameState.benchInventory.water);
                     gameState.benchInventory.water -= consumeFromBench;
                     amountNeeded -= consumeFromBench;
                     console.log(`Consumed ${consumeFromBench} of ${itemId} from bench.`);
                     if (gameState.benchInventory.water <= 0) {
                         delete gameState.benchInventory.water;
                     }
                }


                if (amountNeeded > 0) {
                    console.error(`Ingredient Error: Still needed ${amountNeeded} of ${itemId} after consumption!`);
                }
            }
            updateInventoryUI();
        }

        // NEW: Consume water for respawn
        function consumeWaterForRespawn() {
            if ((gameState.inventory.water || 0) > 0) {
                gameState.inventory.water--;
                console.log("Consumed 1 water from player inventory for respawn.");
                updateInventoryUI();
                return true;
            } else if ((gameState.benchInventory.water || 0) > 0) {
                // Less likely, but check bench if player has none
                gameState.benchInventory.water--;
                 console.log("Consumed 1 water from bench inventory for respawn.");
                 if (gameState.benchInventory.water <= 0) delete gameState.benchInventory.water;
                 updateInventoryUI();
                return true;
            }
            console.log("Respawn failed: No water available.");
            // updateStatus("As plantas precisam de √°gua para crescer! Colete mais √°gua.", "error"); // Maybe too spammy
            return false;
        }


        function getRootInteractiveObject(intersectedPart) { /* ... Unchanged ... */ if (!intersectedPart) return null; let object = intersectedPart; while (object.parent && object.parent !== scene) { if (interactiveObjects.includes(object)) { return object; } object = object.parent; } if (interactiveObjects.includes(object)) { return object; } return null; }
        function focusOnPlant(targetMesh, yOffset = 1.5, zOffset = 3.5) { /* ... Unchanged ... */ if (currentControlsMode !== 'orbit' || isAnimatingCamera) return; isAnimatingCamera = true; orbitControls.enabled = false; const targetPosition = new THREE.Vector3(); targetMesh.getWorldPosition(targetPosition); const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection); const offset = cameraDirection.multiplyScalar(-zOffset).add(new THREE.Vector3(0, yOffset, 0)); const cameraTargetPosition = targetPosition.clone().add(offset); const lookAtTarget = targetPosition.clone().add(new THREE.Vector3(0, 0.5, 0)); gsap.to(camera.position, { x: cameraTargetPosition.x, y: cameraTargetPosition.y, z: cameraTargetPosition.z, duration: 1.0, ease: "power2.inOut" }); gsap.to(orbitControls.target, { x: lookAtTarget.x, y: lookAtTarget.y, z: lookAtTarget.z, duration: 1.0, ease: "power2.inOut", onUpdate: () => orbitControls.update(), onComplete: () => { isAnimatingCamera = false; if(currentControlsMode === 'orbit') { orbitControls.enabled = true; } } }); }

        function showInfoPanel(data, triggerMissionCheck = false) { /* ... showInfoPanel (Handles wood info) ... */
            if (!data || (data.type !== 'plant' && data.type !== 'wood')) { // Check for plant or wood
                hideInfoPanel();
                return;
            }
            plantNameEl.textContent = data.name || 'Item Desconhecido';
            plantGroupEl.textContent = data.type === 'plant' ? (plantGroups[data.group]?.name || 'Desconhecido') : 'Recurso'; // Group or Resource
            plantBenefitsEl.innerHTML = data.desc.replace(/\*([^*]+)\*/g, '<em>$1</em>') || 'Nenhuma descri√ß√£o dispon√≠vel.';
            plantLinkEl.href = data.link || '#'; // Link might not apply to wood
            plantLinkEl.style.display = data.link ? 'inline-block' : 'none'; // Hide link if none

            infoPanel.classList.add('visible');
            hideInstructions();

            if (triggerMissionCheck && !gameState.gameComplete && data.type === 'plant') { // Only trigger knowledge for plants
                const plantId = data.id;
                if (!gameState.knowledgeBase[plantId]) {
                    gameState.knowledgeBase[plantId] = true;
                    const originalPlantData = plantasData.find(p => p.id === plantId);
                    if (originalPlantData) originalPlantData.info_viewed = true;
                    console.log(`Knowledge acquired for: ${plantId}`);
                    updateStatus(`Voc√™ aprendeu sobre: ${data.name}! üåø`, 'highlight');
                    updateMissionPanel();
                    checkMissionCompletion();
                }
            }
        }
        function hideInfoPanel() { infoPanel.classList.remove('visible'); }
        function hideInstructions() { instructionsEl.classList.add('hidden'); }
        closeInfoButton.addEventListener('click', hideInfoPanel);

        // --- Mission Logic (State Updates & Completion Check) ---
        function updateStatus(message, type = 'info', persistent = false) { /* ... unchanged ... */ statusMessageEl.textContent = message; let color = '#b2dfdb'; if (type === 'success') color = '#a5d6a7'; else if (type === 'error') color = '#ef9a9a'; else if (type === 'highlight') color = '#ffeb3b'; statusMessageEl.style.color = color; gsap.killTweensOf(statusMessageEl); statusMessageEl.style.opacity = 1; if (statusMessageEl.gsapTimeout) { clearTimeout(statusMessageEl.gsapTimeout); statusMessageEl.gsapTimeout = null; } if (!persistent) { statusMessageEl.gsapTimeout = setTimeout(() => { gsap.to(statusMessageEl, { opacity: 0, duration: 0.5, onComplete: () => { if (statusMessageEl.textContent === message) { statusMessageEl.textContent = "Siga as instru√ß√µes no Di√°rio do Herbalista."; statusMessageEl.style.color = '#b2dfdb'; statusMessageEl.style.opacity = 1; } statusMessageEl.gsapTimeout = null; }}); }, 5500); } }
        function updateMissionPanel() { /* ... unchanged ... */ if (gameState.gameComplete) { currentMissionEl.innerHTML = "<strong>Todas as miss√µes conclu√≠das! Parab√©ns!</strong> üéâ"; currentMissionEl.style.borderColor = '#4CAF50'; updateKnowledgeList(); updateCraftedList(); updateExtractedOilsList(); updateInventoryUI(); return; } const mission = missions[gameState.currentMissionIndex]; if (mission) { currentMissionEl.innerHTML = mission.description.replace(/\[(.*?)\]/g, '<strong>$1</strong>'); currentMissionEl.style.borderColor = '#ffeb3b'; } else { currentMissionEl.textContent = "Erro: Miss√£o n√£o encontrada."; currentMissionEl.style.borderColor = '#f44336'; } updateKnowledgeList(); updateCraftedList(); updateExtractedOilsList(); updateInventoryUI(); }
        function updateKnowledgeList() { /* ... Unchanged ... */ knowledgeBaseEl.innerHTML = ''; let count = 0; Object.keys(gameState.knowledgeBase).sort().forEach(plantId => { if (gameState.knowledgeBase[plantId]) { const plantData = plantasData.find(p => p.id === plantId); const li = document.createElement('li'); li.textContent = plantData ? plantData.name : plantId; knowledgeBaseEl.appendChild(li); count++; } }); if (count === 0) knowledgeBaseEl.innerHTML = '<li>Nenhuma planta estudada.</li>'; }
        function updateCraftedList() { /* ... Unchanged ... */ craftedItemsEl.innerHTML = ''; let count = 0; Object.keys(gameState.craftedItems).sort().forEach(itemId => { if (gameState.craftedItems[itemId]) { const recipe = recipes[itemId]; const li = document.createElement('li'); li.textContent = recipe ? recipe.name : itemId; craftedItemsEl.appendChild(li); count++; } }); if (count === 0) craftedItemsEl.innerHTML = '<li>Nenhuma prepara√ß√£o feita.</li>'; }
        function updateExtractedOilsList() { /* ... Unchanged ... */ extractedOilsEl.innerHTML = ''; let count = 0; Object.keys(gameState.extractedOils).sort().forEach(oilId => { if (gameState.extractedOils[oilId]) { const li = document.createElement('li'); li.textContent = getOilDisplayName(oilId); extractedOilsEl.appendChild(li); count++; } }); if (count === 0) extractedOilsEl.innerHTML = '<li>Nenhum √≥leo essencial extra√≠do.</li>'; }

        function updateInventoryUI() { /* ... updateInventoryUI (displays wood) ... */
            inventoryListEl.innerHTML = '';
            let playerItemCount = 0;
            // Sort order: Plants, Wood, Water
            const playerSortedItems = Object.keys(gameState.inventory).sort((a, b) => {
                const typeA = a === 'water' ? 2 : (a === 'wood' ? 1 : 0);
                const typeB = b === 'water' ? 2 : (b === 'wood' ? 1 : 0);
                if (typeA !== typeB) return typeA - typeB;
                return getItemDisplayName(a).localeCompare(getItemDisplayName(b));
            });

            playerSortedItems.forEach(itemId => {
                const count = gameState.inventory[itemId];
                if (count > 0) {
                    const li = document.createElement('li');
                    let itemName = getItemDisplayName(itemId);
                    let itemType = 'unknown';
                    if (itemId === 'water') itemType = 'water';
                    else if (itemId === 'wood') itemType = 'wood'; // NEW
                    else if (plantasData.some(p => p.id === itemId)) itemType = 'plant';

                    li.textContent = `${itemName}: ${count}`;
                    li.dataset.type = itemType;
                    inventoryListEl.appendChild(li);
                    playerItemCount++;
                } else if (itemId !== 'water' && itemId !== 'wood') { // Keep water/wood keys even if 0
                    delete gameState.inventory[itemId];
                }
            });
            if (playerItemCount === 0) {
                inventoryListEl.innerHTML = '<li>Vazio</li>';
            }

            // Bench Inventory (Should only contain plants and maybe water)
            benchInventoryListEl.innerHTML = '';
            let benchItemCount = 0;
            const benchSortedItems = Object.keys(gameState.benchInventory).sort((a, b) => {
                 if (a === 'water') return 1; if (b === 'water') return -1; return getItemDisplayName(a).localeCompare(getItemDisplayName(b));
            });
            benchSortedItems.forEach(itemId => {
                const count = gameState.benchInventory[itemId];
                if (count > 0) {
                    const li = document.createElement('li');
                    let itemName = getItemDisplayName(itemId);
                    let itemType = 'unknown';
                    if (itemId === 'water') itemType = 'water';
                    else if (plantasData.some(p => p.id === itemId)) itemType = 'plant';
                    // No wood expected on bench
                    li.textContent = `${itemName}: ${count}`;
                    li.dataset.type = itemType;
                    benchInventoryListEl.appendChild(li);
                    benchItemCount++;
                } else {
                    delete gameState.benchInventory[itemId];
                }
            });
            if (benchItemCount === 0) {
                benchInventoryListEl.innerHTML = '<li>Vazio</li>';
            }
        }


        // MODIFIED: checkMissionCompletion (Handles wood, firepit, updated oil extraction)
        function checkMissionCompletion() {
             if (gameState.gameComplete) return;
             const mission = missions[gameState.currentMissionIndex];
             if (!mission || mission.alreadyCompleted) return;

             let completed = false;
             const focusUd = objectInFocus ? objectInFocus.userData : null;
             const interactionTarget = focusUd ? focusUd.type : null; // bench, firepit, npc etc.

             switch (mission.type) {
                 case 'message': completed = true; break;
                 case 'unlock_feature': completed = true; break;
                 case 'find_object':
                     completed = (focusUd && focusUd.id === mission.targetObjectId);
                     if (completed) console.log(`Mission Check: Found object ${mission.targetObjectId}`);
                     break;
                 case 'find_npc':
                     completed = (focusUd && focusUd.type === 'npc' && focusUd.id === mission.targetNpcId);
                     if (completed) console.log(`Mission Check: Found NPC ${mission.targetNpcId}`);
                     break;
                 case 'npc_dialogue':
                     // Completed by simply interacting (handled in interactWithNPC)
                     completed = (focusUd && focusUd.type === 'npc' && focusUd.id === mission.targetNpcId);
                     if (completed) console.log(`Mission Check: Talked to NPC ${mission.targetNpcId}`);
                     break;
                 case 'collect_or_deposit':
                     // Checks total amount across player inventory and bench
                     const totalAmount = (gameState.inventory[mission.item] || 0) + (gameState.benchInventory[mission.item] || 0);
                     completed = totalAmount >= mission.amount;
                     if(completed) console.log(`Mission Check: Have required amount of ${mission.item} (${totalAmount}/${mission.amount})`);
                     break;
                 case 'craft_item': // Phyto only
                     completed = gameState.craftedItems[mission.recipeId] === true && interactionTarget === 'crafting_bench'; // Must be at bench
                     if (completed) console.log(`Mission Check: Crafted item ${mission.recipeId} at bench`);
                     break;
                 case 'extract_oil': // Oil only
                     completed = gameState.extractedOils[mission.targetOilId] === true && interactionTarget === 'firepit'; // Must be at firepit
                     if (completed) console.log(`Mission Check: Extracted oil ${mission.targetOilId} at firepit`);
                     break;
                 case 'deliver_item_to_npc':
                     let hasItemToDeliver = false;
                     if (mission.requiredItemType === 'phyto' && gameState.craftedItems[mission.requiredItemId]) {
                         hasItemToDeliver = true;
                     } else if (mission.requiredItemType === 'oil' && gameState.extractedOils[mission.requiredItemId]) {
                         hasItemToDeliver = true;
                     }
                     // Completion requires being focused on the correct NPC AND having the item
                     completed = (focusUd && focusUd.type === 'npc' && focusUd.id === mission.targetNpcId && hasItemToDeliver);
                     if (completed) {
                         console.log(`Mission Check: Delivering ${mission.requiredItemId} to ${mission.targetNpcId}`);
                         // Consume item upon successful delivery check
                         if (mission.requiredItemType === 'phyto') {
                             delete gameState.craftedItems[mission.requiredItemId];
                         } else if (mission.requiredItemType === 'oil') {
                             delete gameState.extractedOils[mission.requiredItemId];
                         }
                         gameState.npcStates[mission.targetNpcId] = true; // Mark NPC as helped (redundant with interactNPC, but safe)
                         updateInventoryUI(); // Update UI after consumption
                         updateMissionPanel(); // Update lists
                         console.log(`Item ${mission.requiredItemId} consumed after delivery confirmation.`);
                     }
                     break;
                 default:
                     console.warn("Tipo de miss√£o desconhecido para verifica√ß√£o:", mission.type);
                     break;
             }

             if (completed) { /* ... Post-completion logic (Added wood unlock) ... */
                 mission.alreadyCompleted = true;
                 console.log(`Mission Conclu√≠da: ${mission.id} - ${mission.description.substring(0, 30)}...`);

                 if (mission.type === 'unlock_feature') {
                     switch (mission.feature) {
                         case 'collect_plant': gameState.canCollectPlant = true; updateStatus("Voc√™ pode coletar plantas [F]!", 'highlight'); break;
                         case 'collect_wood': gameState.canCollectWood = true; updateStatus("Voc√™ pode coletar lenha [F]!", 'highlight'); break; // NEW
                         case 'deposit': updateStatus("Deposite plantas [F] na bancada para organizar!", 'highlight'); break;
                         case 'phyto': gameState.canCraftPhyto = true; updateStatus("Preparo de Ch√°s [G] liberado na Bancada!", 'highlight'); break;
                         case 'oils': gameState.canExtractOil = true; updateStatus("Extra√ß√£o de √ìleos Essenciais [G] liberada na Fogueira!", 'highlight'); break; // Updated message
                     }
                 } else if (mission.type !== 'message' && mission.type !== 'deliver_item_to_npc') { // Don't show generic message for delivery
                     updateStatus(`Miss√£o Conclu√≠da!`, 'success');
                 }

                 gameState.currentMissionIndex++;
                 if (gameState.currentMissionIndex >= missions.length) {
                     gameState.gameComplete = true;
                     updateStatus("Parab√©ns Mestre Herbalista! Voc√™ ajudou a todos!", 'highlight', true);
                     console.log("Jogo Conclu√≠do!");
                 }
                 updateMissionPanel(); // Update UI with new mission

                 // Auto-advance next simple mission
                 const nextMission = missions[gameState.currentMissionIndex];
                 if (nextMission && !gameState.gameComplete) {
                     if (nextMission.type === 'message' || nextMission.type === 'unlock_feature') {
                         // Short delay before checking the next simple mission
                         setTimeout(() => { checkMissionCompletion(); }, 1500);
                     }
                     // No automatic check for other types, requires player action
                 }
             }
        }


        // --- Minimap Logic ---
        const minimapCanvas = document.getElementById('minimap-canvas'); const minimapSize = 150; minimapCanvas.width = minimapSize; minimapCanvas.height = minimapSize; const minimapCtx = minimapCanvas.getContext('2d'); const minimapWorldSize = 70; const minimapScale = minimapSize / minimapWorldSize; let lastMinimapUpdateTime = 0; const minimapUpdateInterval = 100;
        function worldToMinimap(wp){ const mX=(wp.x/minimapWorldSize)*minimapSize+minimapSize/2; const mY=(-wp.z/minimapWorldSize)*minimapSize+minimapSize/2; return{x:mX,y:mY};}
        function drawMinimapMarker(ctx,pos,color,size=3,shape='circle'){ /* ... drawMinimapMarker (Added wood & firepit shapes) ... */
            if(!pos)return;
            const mP=worldToMinimap(pos);
            const cX=Math.max(size,Math.min(minimapSize-size,mP.x));
            const cY=Math.max(size,Math.min(minimapSize-size,mP.y));
            ctx.fillStyle=color;
            if(shape==='circle'){ctx.beginPath(); ctx.arc(cX,cY,size,0,Math.PI*2); ctx.fill();}
            else if(shape==='square'){ctx.fillRect(cX-size/2,cY-size/2,size,size);}
            else if(shape==='bench'){ ctx.fillStyle='#8B4513'; ctx.fillRect(cX - 4, cY - 2, 8, 4);}
            else if(shape==='water'){ ctx.fillStyle='#64b5f6'; ctx.beginPath(); ctx.arc(cX,cY,size+1,0,Math.PI*2); ctx.fill();}
            else if(shape === 'npc'){ ctx.fillStyle = color; ctx.beginPath(); ctx.arc(cX, cY, size+1, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(cX, cY, size-1, 0, Math.PI*2); ctx.fill(); }
            else if(shape === 'wood'){ ctx.fillStyle = '#8D6E63'; ctx.fillRect(cX - 2, cY - 2, 4, 4); } // NEW: Wood marker
            else if(shape === 'firepit'){ ctx.fillStyle = '#FF6600'; ctx.beginPath(); ctx.arc(cX, cY, size, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#78909C'; ctx.lineWidth = 1; ctx.stroke(); } // NEW: Firepit marker
        }
        function updateMinimap(ct){ /* ... updateMinimap (Draws wood & firepit) ... */
            if(ct-lastMinimapUpdateTime<minimapUpdateInterval)return;
            lastMinimapUpdateTime=ct;
            minimapCtx.fillStyle='rgba(0,0,0,0.7)';
            minimapCtx.fillRect(0,0,minimapSize,minimapSize);
            // Draw Plants
            plantMeshes.forEach(m=>{if(!m||!m.position||!m.userData||m.userData.isCollected)return; const gC=plantGroups[m.userData.group]?.color||0xffffff; drawMinimapMarker(minimapCtx,m.position,`#${new THREE.Color(gC).getHexString()}`,2,'circle');});
            // Draw Wood
            woodMeshes.forEach(m => { if (!m || !m.position || !m.userData || m.userData.isCollected) return; drawMinimapMarker(minimapCtx, m.position, `#${new THREE.Color(m.userData.color).getHexString()}`, 2, 'wood'); }); // NEW
            // Draw NPCs
            npcMeshes.forEach(npc => { if (!npc || !npc.position || !npc.userData) return; const npcColor = `#${new THREE.Color(npc.userData.color || 0xffffff).getHexString()}`; drawMinimapMarker(minimapCtx, npc.position, npcColor, 3, 'npc'); });
            // Draw Bench, Firepit, Water Source
            if(craftingBenchMesh) { drawMinimapMarker(minimapCtx, craftingBenchMesh.position, '#8B4513', 4, 'bench'); }
            if(firepitMesh) { drawMinimapMarker(minimapCtx, firepitMesh.position, '#FF6600', 3, 'firepit'); } // NEW
            if(waterSourceMesh) { drawMinimapMarker(minimapCtx, waterSourceMesh.position, '#64b5f6', 3, 'water'); }
            // Draw Bee
            if(bee) { drawMinimapMarker(minimapCtx, bee.position, '#FFD700', 2, 'circle'); }
            // Draw Player
            const pPos=pointerLockControls.isLocked?pointerLockControls.getObject().position:camera.position;
            drawMinimapMarker(minimapCtx,pPos,'#FFFFFF',4,'square');
        }


        // --- Window Resize Handling ---
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }, false);

        // --- Animation Loop (Added Water Consumption, Wood Respawn) ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const currentTime = performance.now();
            const playerPosition = pointerLockControls.getObject().position; // Get player position once

            // --- Water Resource Respawn Logic ---
            if (!gameState.isWaterResourceAvailable) { /* ... unchanged ... */
                gameState.waterResourceRespawnTimer -= delta;
                if (gameState.waterResourceRespawnTimer <= 0) {
                    gameState.isWaterResourceAvailable = true;
                    waterResourceMesh.visible = true;
                    waterResourceMesh.scale.set(0.1, 0.1, 0.1);
                    gsap.to(waterResourceMesh.scale, {x: 1, y: 1, z: 1, duration: 0.3, ease: "back.out(1.7)"});
                    console.log("Water Resource Spawned");
                }
            } else { /* ... unchanged ... */
                waterResourceMesh.position.y = waterSourceMesh.position.y + 0.8 + Math.sin(currentTime * 0.002) * 0.05;
            }


            // --- FPV Mode Logic ---
            if (currentControlsMode === 'fpv' && pointerLockControls.isLocked) {
                handleFocusRaycast();

                // Movement
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(moveState.forward) - Number(moveState.backward); direction.x = Number(moveState.right) - Number(moveState.left); direction.normalize();
                if (moveState.forward || moveState.backward) { velocity.z -= direction.z * moveSpeed * 50.0 * delta; }
                if (moveState.left || moveState.right) { velocity.x -= direction.x * moveSpeed * 50.0 * delta; }
                pointerLockControls.moveRight(-velocity.x * delta); pointerLockControls.moveForward(-velocity.z * delta);
                playerPosition.y = 1.6; // Update player position y AFTER movement

                // --- Automatic Water Resource Collection Check (FPV Only) ---
                if (gameState.isWaterResourceAvailable && waterResourceMesh.visible) { /* ... unchanged ... */
                     const distanceToWaterResource = playerPosition.distanceTo(waterResourceMesh.position);
                     if (distanceToWaterResource < WATER_RESOURCE_COLLECT_DISTANCE) {
                         console.log("Collecting Water Resource by proximity");
                         collectWater(); // Call the existing collect function
                         gameState.isWaterResourceAvailable = false; // Mark as collected
                         waterResourceMesh.visible = false; // Hide mesh
                         gameState.waterResourceRespawnTimer = WATER_RESOURCE_RESPAWN_TIME; // Reset timer
                     }
                }

                // Bee Balloon Check
                 const beeDistance = bee ? playerPosition.distanceTo(bee.position) : Infinity;
                 if (beeDistance < 3.0 && (!objectInFocus || objectInFocus.userData?.type !== 'bee_link')) {
                      beeBalloon.style.display = 'block';
                 } else { beeBalloon.style.display = 'none'; }

            }
            // --- Orbit Mode Logic ---
            else if (currentControlsMode === 'orbit' && orbitControls.enabled) {
                orbitControls.update();
                beeBalloon.style.display = 'none';
            }

            // --- Plant Respawn Logic (with Water Consumption) ---
            plantMeshes.forEach(plantMesh => {
                const ud = plantMesh.userData;
                if (ud.isCollected && ud.respawnTimer > 0) {
                    ud.respawnTimer -= delta;
                    if (ud.respawnTimer <= 0) {
                        // Attempt to consume water BEFORE respawning
                        if (consumeWaterForRespawn()) {
                            ud.isCollected = false;
                            plantMesh.visible = true;
                            console.log(`${ud.name} respawned (consumed 1 water).`);
                        } else {
                            // Failed to respawn due to lack of water, reset timer slightly
                            ud.respawnTimer = 0.1; // Check again soon
                            console.log(`Respawn failed for ${ud.name}: No water.`);
                        }
                    }
                }
            });

            // --- Wood Respawn Logic ---
            woodMeshes.forEach(woodMesh => {
                 const ud = woodMesh.userData;
                 if (ud.isCollected && ud.respawnTimer > 0) {
                     ud.respawnTimer -= delta;
                     if (ud.respawnTimer <= 0) {
                         ud.isCollected = false;
                         woodMesh.visible = true;
                         console.log(`${ud.name} respawned.`);
                     }
                 }
            });


            updatePlantLabels(); // Update Plant & Wood Labels

            // --- Bee Animation & Balloon ---
            if (bee) { /* ... unchanged Bee animation ... */ const time = clock.getElapsedTime(); bee.position.y = 1.5 + Math.sin(time * 3) * 0.08; const pathRadiusX = 6; const pathRadiusZ = 4; const pathSpeed = 0.4; const offsetX = 3; const offsetZ = -5; bee.position.x = offsetX + Math.sin(time * pathSpeed) * pathRadiusX; bee.position.z = offsetZ + Math.sin(time * pathSpeed * 2) * pathRadiusZ; const nextX = offsetX + Math.sin((time + 0.1) * pathSpeed) * pathRadiusX; const nextZ = offsetZ + Math.sin((time+0.1) * pathSpeed * 2) * pathRadiusZ; bee.lookAt(nextX, bee.position.y, nextZ); }
            updateBalloonPosition();

            // --- Firepit Animation (subtle flicker) ---
            if (firepitMesh) {
                const fireGlow = firepitMesh.children.find(c => c.material.color.getHex() === 0xff6600);
                if (fireGlow) {
                    const flicker = Math.random() * 0.1 + 0.95;
                    fireGlow.scale.set(flicker, flicker, flicker);
                    const fireLight = fireGlow.children.find(l => l.isPointLight);
                    if (fireLight) {
                        fireLight.intensity = 0.7 + Math.random() * 0.3;
                    }
                }
            }


            updateMinimap(currentTime); // Update Minimap
            renderer.render(scene, camera); // Render Scene
        }

        // --- Update Plant/Wood Labels Positions and Visibility ---
        function updatePlantLabels() { /* ... updatePlantLabels (Handles both plant and wood labels) ... */
            const cameraPosition = camera.position;
            const allLabeledObjects = [...plantMeshes, ...woodMeshes]; // Combine plants and wood

            allLabeledObjects.forEach(mesh => {
                const label = plantLabelElements[mesh.userData.id]; // Use the common label store
                if (!label || mesh.userData.isCollected) {
                    if(label) label.classList.remove('visible', 'pulsing');
                    return;
                }
                const position = mesh.position;
                const distanceToCamera = cameraPosition.distanceTo(position);

                if (distanceToCamera < labelMaxDistance && distanceToCamera > 0.5) {
                    tempVector.copy(position).add(new THREE.Vector3(0, 1.0, 0)); // Label position offset
                    tempVector.project(camera);

                    if (tempVector.z > 1) { // Check if behind camera
                        label.classList.remove('visible', 'pulsing');
                        return;
                    }

                    const x = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-tempVector.y * 0.5 + 0.5) * window.innerHeight;
                    label.style.left = `${x}px`;
                    label.style.top = `${y}px`;
                    label.classList.add('visible', 'pulsing');
                } else {
                    label.classList.remove('visible', 'pulsing');
                }
            });
        }

        // --- Bee Balloon Positioning ---
        function updateBalloonPosition() { /* ... Unchanged ... */ if (!bee || beeBalloon.style.display === 'none') return; const vector = new THREE.Vector3(); const head = bee.children.find(c => c.geometry.type === 'BoxGeometry' && c.position.x < 0); const worldPos = head ? head.getWorldPosition(vector) : bee.getWorldPosition(vector); worldPos.project(camera); const x = (worldPos.x * 0.5 + 0.5) * window.innerWidth; const y = (-worldPos.y * 0.5 + 0.5) * window.innerHeight; beeBalloon.style.left = `${x - beeBalloon.offsetWidth / 2}px`; beeBalloon.style.top = `${y - beeBalloon.offsetHeight - 10}px`; }

        // --- Initial Setup ---
        craftingBenchMesh = createCraftingBench();
        firepitMesh = createFirepitMesh(); // NEW
        waterSourceMesh = createWaterSource();
        waterResourceMesh = createWaterResourceMesh(waterSourceMesh.position);
        bee = createBee();
        // NPCs and Wood created earlier

        orbitControls.enabled = true; pointerLockControls.enabled = false;
        controlsToggleButton.textContent = 'Ativar Vis√£o Pessoal';

        updateInventoryUI();
        updateMissionPanel();
        checkMissionCompletion(); // Initial check for simple missions

        animate(); // Start the game loop

    </script>
</body>
</html>
