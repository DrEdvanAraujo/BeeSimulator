<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Apiter√°pico - V4.5: Progress√£o Corrigida</title> <!-- Updated Title -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* --- Base Styles (Keep previous styles) --- */
        body, html { margin: 0; padding: 0; overflow: hidden; font-family: 'Arial', sans-serif; color: white; background-color: #333; }
        #game-container { width: 100vw; height: 100vh; position: relative; top: 0; left: 0; z-index: 1; }
        #info-panel { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 10px; width: 350px; max-height: calc(100vh - 40px - 150px); overflow-y: auto; z-index: 2; color: #eee; }
        .mission-header { font-size: 1.1em; font-weight: bold; margin-bottom: 10px; padding: 8px; background-color: rgba(255, 193, 7, 0.2); border-left: 4px solid #ffc107; border-radius: 4px; }
        .mission-phase1 { border-left: 4px solid #ffc107; background-color: rgba(255, 193, 7, 0.2); } /* Explicit Phase 1 Style */
        .mission-phase2 { border-left: 4px solid #00bcd4; background-color: rgba(0, 188, 212, 0.2); }
        .mission-phase3 { border-left: 4px solid #ff9800; background-color: rgba(255, 152, 0, 0.2); }
        h4, h5 { border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 10px; }
        ul { list-style: none; padding-left: 0; }
        li { margin-bottom: 5px; }
        #status-message { margin-top: 15px; padding: 10px; background-color: rgba(255, 255, 255, 0.1); border-radius: 5px; min-height: 40px; font-style: italic; color: #aaaaff; }
        #pacientes div { margin-bottom: 8px; padding: 5px; border-radius: 4px; background-color: rgba(255, 255, 255, 0.05); }
        #pacientes div:nth-child(odd) { background-color: rgba(255, 255, 255, 0.1); }
        .storage-section li { font-size: 0.9em; }
        .carrying { color: #ffeb3b; }
        .hive { color: #8bc34a; }
        .venom-storage { color: #ff00ff; font-weight: bold;}
        .water-storage { color: #03a9f4; font-weight: bold;}
        .homeopathic-storage { color: #4caf50; font-weight: bold; }
        .cera-storage { color: #FFA500; font-weight: bold; }
        #mission-area { margin-bottom: 15px; }
        #trophy-display { margin-top: 10px; color: #FFD700; font-weight: bold; }
        #nursery-status { margin-top: 10px; color:#FFA500; }
        #minimap-container { position: absolute; bottom: 10px; right: 10px; width: 150px; height: 150px; border: 2px solid rgba(255, 255, 255, 0.5); background-color: rgba(0, 0, 0, 0.6); border-radius: 5px; z-index: 2; }
        #minimap-canvas { width: 100%; height: 100%; display: block; }
        .dialog-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 600px; max-width: 90%; background: rgba(0, 0, 0, 0.9); border-radius: 15px; padding: 20px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); z-index: 10; visibility: hidden; opacity: 0; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
        .dialog-container.visible { visibility: visible; opacity: 1; transition: opacity 0.3s ease; }
        .dialog-content { position: relative; }
        .dialog-header { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; }
        .npc-name { font-size: 1.2em; color: #ffc107; }
        .npc-icon { font-size: 2em; }
        .dialog-text { line-height: 1.5; margin-bottom: 15px; }
        .dialog-options { margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; }
        .dialog-option { background: rgba(255, 193, 7, 0.2); border: 1px solid #ffc107; color: white; padding: 8px 15px; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; }
        .dialog-option:hover { background: #ffc107; color: #333; }
        .status-critical { animation: criticalBlink 1s infinite; border: 2px solid #ff0000 !important; }
        @keyframes criticalBlink { 0% { background-color: rgba(255, 0, 0, 0.2); } 50% { background-color: rgba(255, 0, 0, 0.5); } 100% { background-color: rgba(255, 0, 0, 0.2); } }
        .highlight { animation: highlightGlow 2s ease-out forwards; box-shadow: 0 0 0px transparent; }
        @keyframes highlightGlow { 0% { box-shadow: 0 0 15px 5px #ffc107; } 100% { box-shadow: 0 0 0px transparent; } }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="info-panel">
        <h4>Miss√µes Apiter√°picas üêù <span id="phase-indicator"></span></h4>
        <div id="mission-area">
            <h5>Miss√£o Atual:</h5>
            <div id="current-mission" class="mission-header">Carregando miss√£o...</div>
            <div id="trophy-display"></div>
            <div id="nursery-status"></div>
        </div>
        <hr>
        <h5>Invent√°rio & Colmeia</h5>
        <div class="storage-section">
            <div>Capacidade de Carga: <span id="carrying-capacity">0</span></div>
            <h6>Carregando Agora:</h6>
            <ul id="carrying-now"></ul>
            <h6>Recursos na Colmeia:</h6>
            <ul id="hive-storage"></ul>
        </div>
        <hr>
        <h5>Centro de Pr√°ticas Integrativas / Ber√ß√°rio</h5>
        <div id="pacientes"></div>
        <hr>
        <div id="status-message">Use W/A/S/D/Setas, Espa√ßo(Subir)/Shift(Descer). 'E' na Colmeia. Aproxime-se do Apicultor para orienta√ß√µes.</div>
    </div>
    <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>
    <div id="dialog-box" class="dialog-container">
        <div class="dialog-content">
            <div class="dialog-header">
                <span id="npc-icon" class="npc-icon"></span>
                <span id="npc-name" class="npc-name"></span>
            </div>
            <div id="dialog-text" class="dialog-text"></div>
            <div id="dialog-options" class="dialog-options"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Basic Setup --- (Unchanged)
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.getElementById('game-container').appendChild(renderer.domElement); const clock = new THREE.Clock(); const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 15, 10); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20; directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20; scene.add(directionalLight);
        // --- Minimap Setup --- (Unchanged)
        const minimapCanvas = document.getElementById('minimap-canvas'); const minimapSize = 150; minimapCanvas.width = minimapSize; minimapCanvas.height = minimapSize; const minimapCtx = minimapCanvas.getContext('2d'); const minimapWorldSize = 50; const minimapScale = minimapSize / minimapWorldSize;
        // --- Bee Setup --- (Unchanged)
        const beeGroup = new THREE.Group(); const beeBodyGeometry = new THREE.SphereGeometry(0.15, 16, 12); const beeBodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffeb3b }); const beeBody = new THREE.Mesh(beeBodyGeometry, beeBodyMaterial); beeBody.castShadow = true; beeGroup.add(beeBody); const wingGeo = new THREE.PlaneGeometry(0.25, 0.1); const wingMat = new THREE.MeshStandardMaterial({ color: 0xADD8E6, side: THREE.DoubleSide, transparent: true, opacity: 0.7 }); const lWing = new THREE.Mesh(wingGeo, wingMat); lWing.rotation.set(-Math.PI/6, Math.PI/2, 0); lWing.position.set(-0.15, 0.05, 0); beeGroup.add(lWing); const rWing = lWing.clone(); rWing.rotation.set(Math.PI/6, Math.PI/2, 0); rWing.position.set(0.15, 0.05, 0); beeGroup.add(rWing); beeGroup.position.set(0, 0.5, 1); scene.add(beeGroup);
        // --- Environment Setup --- (Unchanged, includes nursery placeholder)
        const groundGeometry = new THREE.PlaneGeometry(80, 80); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x55aa55, side: THREE.DoubleSide }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground); const waterGeometry = new THREE.PlaneGeometry(12, 10); const waterMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, transparent: true, opacity: 0.85, roughness: 0.1, metalness: 0.2, side: THREE.DoubleSide, envMapIntensity: 0.8 }); const water = new THREE.Mesh(waterGeometry, waterMaterial); water.rotation.x = -Math.PI / 2; water.position.set(12, 0.01, 8); water.receiveShadow = true; scene.add(water); const hiveGroup = new THREE.Group(); const hiveBaseGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.8, 12); const hiveBaseMat = new THREE.MeshStandardMaterial({ color: 0xDAA520 }); const hiveBase = new THREE.Mesh(hiveBaseGeo, hiveBaseMat); hiveBase.castShadow = true; hiveBase.receiveShadow = true; hiveGroup.add(hiveBase); const hiveTopGeo = new THREE.SphereGeometry(0.6, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2); const hiveTop = new THREE.Mesh(hiveTopGeo, hiveBaseMat); hiveTop.position.y = 0.4; hiveTop.castShadow = true; hiveTop.receiveShadow = true; hiveGroup.add(hiveTop); const hiveEntranceGeo = new THREE.CircleGeometry(0.1, 12); const hiveEntranceMat = new THREE.MeshBasicMaterial({ color: 0x333333 }); const hiveEntrance = new THREE.Mesh(hiveEntranceGeo, hiveEntranceMat); hiveEntrance.position.set(0, -0.1, 0.61); hiveEntrance.rotation.x = -0.2; hiveGroup.add(hiveEntrance); const hivePosition = new THREE.Vector3(0, 0.4, 0); hiveGroup.position.copy(hivePosition); scene.add(hiveGroup); let nurseryMesh = null; const venomSourceGeo = new THREE.IcosahedronGeometry(0.3, 0); const venomSourceMat = new THREE.MeshStandardMaterial({ color: 0x9400D3, emissive: 0x4B0082, roughness: 0.6 }); const venomSource = new THREE.Mesh(venomSourceGeo, venomSourceMat); const venomSourcePosition = new THREE.Vector3(-15, 0.3, 15); venomSource.position.copy(venomSourcePosition); venomSource.castShadow = true; venomSource.userData = { type: 'venomSource', active: true }; scene.add(venomSource); let activeResources = []; activeResources.push(venomSource); function createTree(x, z) { const trunkHeight = Math.random() * 1.5 + 1; const trunkGeo = new THREE.CylinderGeometry(0.15, 0.2, trunkHeight, 8); const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.position.set(x, trunkHeight / 2, z); trunk.castShadow = true; trunk.receiveShadow = true; scene.add(trunk); const leavesHeight = Math.random() * 1 + 0.5; const leavesGeo = new THREE.SphereGeometry(0.7, 8, 6); const leavesMat = new THREE.MeshStandardMaterial({ color: 0x006400 }); const leaves = new THREE.Mesh(leavesGeo, leavesMat); leaves.position.set(x, trunkHeight + leavesHeight * 0.4, z); leaves.castShadow = true; scene.add(leaves); } createTree(5, -5); createTree(-4, -8); createTree(6, -12); createTree(-7, -3); createTree(0, -10); createTree(10, 8); createTree(-8, 10); createTree(15, -5); createTree(-12, -15); createTree(18, 10); createTree(-10, 18); const waterSourceGeo = new THREE.SphereGeometry(0.1, 8, 6); const waterSourceMat = new THREE.MeshStandardMaterial({ color: 0x03a9f4, emissive: 0x01579b, transparent: true, opacity: 0.8 }); let activeWaterSources = [];

        // --- Game State & Logic Variables ---
        const carryingCapacity = 5;
        const currentlyCarrying = { mel: 0, propolis: 0, polen: 0, geleia: 0, venom: 0, water: 0, cera: 0 }; // Added cera
        const hiveStorage = { mel: 0, propolis: 0, polen: 0, geleia: 0, venom: 0, water: 0, veneno_homeopatico: 0, cera: 0 }; // Added cera
        let pacientes = []; const patientMarkers = [];
        const statusMessageEl = document.getElementById('status-message');
        let missions = []; // Will be assigned phase 1 initially
        let currentMissionIndex = 0;
        let currentPhase = 1; // Start at phase 1
        let phaseComplete = false; // Is the *current* phase complete?
        let awaitingPhaseTransitionTalk = false; // Waiting for player to talk to NPC?
        let hasReceivedTrophy = false;
        let nurseryBuilt = false;

        // --- Missions (Phase 1, 2, 3 Definitions) ---
        const phase1Missions = [ /* ... same as before ... */ { id: 'p1_m1', type: 'collect', target: 'mel', goal: 3, description: "Colete 3 N√©ctar (üçØ Mel) e deposite na Colmeia." }, { id: 'p1_m2', type: 'treat', targetPatientId: 1, description: "Use Mel da Colmeia para tratar Paciente 1 (Ferida)." }, { id: 'p1_m3', type: 'collect', target: 'propolis', goal: 2, description: "Colete 2 Resina (ü™µ Pr√≥polis) e deposite." }, { id: 'p1_m4', type: 'collect', target: 'polen', goal: 4, description: "Colete 4 P√≥len (üåº P√≥len) e deposite." }, { id: 'p1_m5', type: 'treat', targetPatientId: 2, description: "Use Pr√≥polis da Colmeia para tratar Paciente 2 (Infec√ß√£o)." }, { id: 'p1_m6', type: 'treat', targetPatientId: 3, description: "Use P√≥len da Colmeia para tratar Paciente 3 (Imunidade)." }, { id: 'p1_m7', type: 'collect_special', target: 'venom', goal: 1, description: `Colete 1 dose de ‚ò†Ô∏è Veneno da Flor Roxa (${venomSourcePosition.x.toFixed(0)}, ${venomSourcePosition.z.toFixed(0)}) e deposite.` }, { id: 'p1_m8', type: 'treat', targetPatientId: 5, description: "Use Veneno da Colmeia para tratar Paciente 5 (Dor Cr√¥nica)." }, { id: 'p1_m9', type: 'collect', target: 'geleia', goal: 1, description: "Colete 1 Geleia Real (üëë Geleia Real) e deposite." }, { id: 'p1_m10', type: 'treat', targetPatientId: 4, description: "Use Geleia Real da Colmeia para tratar Paciente 4 (Envelhecimento)." }, { id: 'p1_complete', type: 'complete_phase1', description: "Fase 1 conclu√≠da! Aproxime-se do Apicultor para continuar." } ];
        const phase2Missions = [ /* ... same as before with increased goals ... */ { id: 'p2_m1', type: 'collect', target: 'water', goal: 5, description: "Colete 5 üíß √Ågua sobrevoando o lago e deposite." }, { id: 'p2_m2', type: 'treat', targetPatientId: 6, description: "Use √Ågua da Colmeia para tratar Paciente 6 (Desidrata√ß√£o)." }, { id: 'p2_m3', type: 'craft', requires: { venom: 1, water: 3 }, yields: 'veneno_homeopatico', goal: 1, description: "Colete ‚ò†Ô∏è Veneno (1) e üíß √Ågua (3). Deposite para criar üß™ Veneno Homeop√°tico na colmeia." }, { id: 'p2_m4', type: 'treat', targetPatientId: 7, description: "Use üß™ Veneno Homeop√°tico da Colmeia para tratar Paciente 7 (Alergia Leve)." }, { id: 'p2_m5', type: 'collect', target: 'propolis', goal: 6, description: "Colete 6 ü™µ Pr√≥polis e deposite." }, { id: 'p2_m6', type: 'treat', targetPatientId: 8, description: "Use Pr√≥polis da Colmeia para tratar Paciente 8 (Irrita√ß√£o na Pele)." }, { id: 'p2_m7', type: 'collect', target: 'mel', goal: 4, description: "Colete 4 üçØ Mel e deposite." }, { id: 'p2_m8', type: 'collect', target: 'polen', goal: 5, description: "Colete 5 üåº P√≥len e deposite." }, { id: 'p2_m9', type: 'treat', targetPatientId: 9, description: "Use Mel ou P√≥len da Colmeia para tratar Paciente 9 (Problema Digestivo)." }, { id: 'p2_m10', type: 'collect', target: 'geleia', goal: 2, description: "Colete 2 üëë Geleia Real e deposite." }, { id: 'p2_m11', type: 'treat', targetPatientId: 10, description: "Use Geleia Real da Colmeia para tratar Paciente 10 (Fadiga)." }, { id: 'p2_complete', type: 'complete_phase2', description: "Fase 2 conclu√≠da! Aproxime-se do Apicultor para a pr√≥xima etapa." } ];
        const phase3Missions = [ /* ... same as before ... */ { id: 'p3_m1', type: 'build_nursery', goal: 1, description: "Construa o Ber√ß√°rio: Deposite recursos para criar 6 üß± Cera (Req p/ Cera: 3üçØ+3üíß+1üåº)." }, { id: 'p3_m2', type: 'treat', targetPatientId: 11, description: "Use üß± Cera da Colmeia para tratar Paciente 11 (Larva Desnutrida)." }, { id: 'p3_m3', type: 'treat', targetPatientId: 12, description: "Use üß± Cera da Colmeia para tratar Paciente 12 (C√©lula Danificada)." }, { id: 'p3_m4', type: 'treat', targetPatientId: 13, description: "Use üëë Geleia Real da Colmeia para tratar Paciente 13 (Desenvolvimento Lento)." }, { id: 'p3_m5', type: 'treat', targetPatientId: 14, description: "Use ü™µ Pr√≥polis da Colmeia para tratar Paciente 14 (Prote√ß√£o da Cria)." }, { id: 'p3_m6', type: 'treat', targetPatientId: 15, description: "Use üçØ Mel da Colmeia para tratar Paciente 15 (Energia para Crescimento)." }, { id: 'p3_complete', type: 'complete_phase3', description: "Fase 3 conclu√≠da! O Ber√ß√°rio est√° funcional! Fale com o Apicultor." } ];

        // --- Patients (Phase 1, 2, 3 Definitions) ---
        const phase1Patients = [ /* ... same as before ... */ { id: 1, caso: "Ferida grave", produto: "mel", position: new THREE.Vector3(-4, 0.25, -8) }, { id: 2, caso: "Infec√ß√£o", produto: "propolis", position: new THREE.Vector3(-2, 0.25, -8) }, { id: 3, caso: "Imunidade", produto: "polen", position: new THREE.Vector3(0, 0.25, -8) }, { id: 4, caso: "Envelhecimento", produto: "geleia", position: new THREE.Vector3(2, 0.25, -8) }, { id: 5, caso: "Dor Cr√¥nica", produto: "venom", position: new THREE.Vector3(4, 0.25, -8) } ];
        const phase2Patients = [ /* ... same as before ... */ { id: 6, caso: "Desidrata√ß√£o", produto: "water", position: new THREE.Vector3(10, 0.25, 6) }, { id: 7, caso: "Alergia Leve", produto: "veneno_homeopatico", position: new THREE.Vector3(12, 0.25, 4) }, { id: 8, caso: "Irrita√ß√£o Pele", produto: "propolis", position: new THREE.Vector3(14, 0.25, 8) }, { id: 9, caso: "Digest√£o", produto: ['mel', 'polen'], position: new THREE.Vector3(-10, 0.25, -10) }, { id: 10, caso: "Fadiga", produto: "geleia", position: new THREE.Vector3(-8, 0.25, -12) } ];
        const phase3Patients = [ /* ... same as before ... */ { id: 11, caso: "Larva Desnutrida", produto: "cera", position: new THREE.Vector3(1.5, 0.25, 1.5) }, { id: 12, caso: "C√©lula Danificada", produto: "cera", position: new THREE.Vector3(-1.5, 0.25, 1.5) }, { id: 13, caso: "Desenvolvimento Lento", produto: "geleia", position: new THREE.Vector3(0, 0.25, 3) }, { id: 14, caso: "Prote√ß√£o da Cria", produto: "propolis", position: new THREE.Vector3(1.5, 0.25, -1.5) }, { id: 15, caso: "Energia Crescimento", produto: "mel", position: new THREE.Vector3(-1.5, 0.25, -1.5) } ];

        // --- NPC Definition --- (Unchanged)
        const npcGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 12); const npcMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa }); const apicultorNPC = new THREE.Mesh(npcGeo, npcMat); apicultorNPC.position.set(2, 0.6, 2); apicultorNPC.castShadow = true; apicultorNPC.userData = { type: 'npc', id: 'apicultor', name: 'Apicultor Mestre', icon: 'üë¥', currentDialogueId: 'welcome' }; scene.add(apicultorNPC);

        // --- Dialogue System ---
        const dialogBox = document.getElementById('dialog-box'); const npcIconEl = document.getElementById('npc-icon'); const npcNameEl = document.getElementById('npc-name'); const dialogTextEl = document.getElementById('dialog-text'); const dialogOptionsEl = document.getElementById('dialog-options'); let currentNpc = null;
        const dialogData = { /* ... same as V4.4 ... */ apicultor: { welcome: { text: "Ol√°, pequena abelha! O jardim precisa de cuidados e os pacientes esperam. Siga as instru√ß√µes no painel de Miss√µes Atuais para nos ajudar." }, busy_phase1: { text: "Continue seu trabalho na Fase 1, abelha oper√°ria! Siga as miss√µes no painel." }, phase1_complete_prompt: { text: "Incr√≠vel! Voc√™ completou todas as tarefas da Fase 1 e ganhou este Trof√©u Apiter√°pico Dourado! üèÜ Prepare-se para novos desafios!" }, busy_phase2: { text: "Excelente! Continue com as novas miss√µes da Fase 2. Lembre-se da √°gua e das novas receitas!" }, phase2_complete_prompt: { text: "Magn√≠fico trabalho na Fase 2! Para expandir a colmeia, precisamos construir um Ber√ß√°rio. Isso exigir√° um novo material: Cera! Colete os ingredientes e deposite-os." }, busy_phase3: { text: "O Ber√ß√°rio precisa de cuidados! Continue com as miss√µes da Fase 3, focando nas crias e na manuten√ß√£o com Cera." }, phase3_complete_final: { text: "Fant√°stico! O Ber√ß√°rio est√° estabelecido e funcional gra√ßas a voc√™! A colmeia pode agora crescer forte e saud√°vel. Seu trabalho aqui foi exemplar!" } } };
        function showDialog(npc) { /* ... Same 'Ok' button logic ... */ if (!npc || !npc.userData || !npc.userData.id || !dialogBox) return; const npcId = npc.userData.id; const dialogueId = npc.userData.currentDialogueId; const dialogueNode = dialogData[npcId]?.[dialogueId]; if (!dialogueNode) { console.warn(`Dialogue node not found for NPC ${npcId}, ID ${dialogueId}. Hiding.`); hideDialog(); return; } const isVisible = dialogBox.classList.contains('visible'); const needsUpdate = !isVisible || currentNpc !== npc || npc.userData.currentDisplayedDialogueId !== dialogueId; if (needsUpdate) { currentNpc = npc; npcIconEl.textContent = npc.userData.icon || '‚ùî'; npcNameEl.textContent = npc.userData.name || 'NPC'; dialogTextEl.textContent = dialogueNode.text; dialogOptionsEl.innerHTML = ''; const okButton = document.createElement('button'); okButton.className = 'dialog-option'; okButton.textContent = 'Ok.'; okButton.onclick = () => handleDialogOption(dialogueId, npc); dialogOptionsEl.appendChild(okButton); npc.userData.currentDisplayedDialogueId = dialogueId; if (!isVisible) { dialogBox.classList.add('visible'); } } }
        function hideDialog() { /* ... Unchanged ... */ if (dialogBox && dialogBox.classList.contains('visible')) { dialogBox.classList.remove('visible'); if (currentNpc && currentNpc.userData) { delete currentNpc.userData.currentDisplayedDialogueId; } currentNpc = null; } }

        // REVISED: handleDialogOption triggers phase transitions based on awaiting flag and dialog ID
        function handleDialogOption(closedDialogueId, npc) {
             hideDialog();
             if (awaitingPhaseTransitionTalk) {
                 if (closedDialogueId === 'phase1_complete_prompt' && currentPhase === 1) {
                     startPhase2();
                 } else if (closedDialogueId === 'phase2_complete_prompt' && currentPhase === 2) {
                     startPhase3();
                 }
                  // Add else if for phase 3 -> 4 transition if needed
             }
        }

        // --- Phase Transition Functions (Revised) ---
        function startPhase2() {
             console.log("Starting Phase 2!");
             currentPhase = 2;
             missions = phase2Missions;
             pacientes = [...phase2Patients]; // Use copy
             currentMissionIndex = 0;
             phaseComplete = false;
             awaitingPhaseTransitionTalk = false;
             hasReceivedTrophy = true; // Grant trophy now
             document.getElementById('trophy-display').textContent = "üèÜ Trof√©u Apiter√°pico Ganho!";
             apicultorNPC.userData.currentDialogueId = 'busy_phase2'; // Set busy state

             clearOldResources(); // Remove P1 resources
             spawnPhase2Resources(); // Spawn P2 resources
             spawnInitialWaterSources(); // Ensure water exists

             setPhaseIndicator();
             updateStatus("Fase 2 iniciada! Novos desafios aguardam.", "success");
             updateInfoPanel();
             checkMissionCompletion(); // Check first mission of new phase
         }

         function startPhase3() {
             console.log("Starting Phase 3!");
             currentPhase = 3;
             missions = phase3Missions;
             pacientes = [...phase3Patients]; // Use copy
             currentMissionIndex = 0;
             phaseComplete = false;
             awaitingPhaseTransitionTalk = false;
             // Trophy already awarded
             apicultorNPC.userData.currentDialogueId = 'busy_phase3'; // Set busy state

             // Keep Phase 2 resources, don't clear. Ensure water still exists/respawns.
             // spawnInitialWaterSources(); // Optionally respawn water if needed

             setPhaseIndicator();
             updateStatus("Fase 3 iniciada! Construa e cuide do Ber√ß√°rio!", "success");
             updateInfoPanel();
             checkMissionCompletion(); // Check first mission (build nursery)
         }

        // --- UI Update Functions ---
        function updateStatus(message, type = 'info') { /* ... Unchanged ... */ statusMessageEl.textContent = message; statusMessageEl.classList.remove('status-critical', 'highlight'); let color = '#aaaaff'; if (type === 'success') color = '#a9ffaa'; else if (type === 'error') color = '#ffaaaa'; else if (type === 'warning') color = '#ffffaa'; else if (type === 'critical') { color = '#ffaaaa'; statusMessageEl.classList.add('status-critical'); } statusMessageEl.style.color = color; if (type !== 'critical') { setTimeout(() => { if (statusMessageEl.textContent === message) { statusMessageEl.textContent = "Use W/A/S/D/Setas, Espa√ßo(Subir)/Shift(Descer). 'E' na Colmeia. Aproxime-se do Apicultor para orienta√ß√µes."; statusMessageEl.style.color = '#aaaaff'; statusMessageEl.classList.remove('status-critical'); } }, 6000); } }
        function updatePacientesUI() { /* ... Unchanged ... */ document.getElementById('pacientes').innerHTML = pacientes.map(p => { let requiredText = ''; const product = getRequiredProductForPatient(p.id); if (product) { if (Array.isArray(product)) { requiredText = `(Req: ${product.map(pr => `${getEmoji(pr)} ${capitalize(pr)}`).join(' ou ')})`; } else { requiredText = `(Req: ${getEmoji(product)} ${capitalize(product)})`; } } const isTarget = !phaseComplete && currentMissionIndex < missions.length && missions[currentMissionIndex].type === 'treat' && missions[currentMissionIndex].targetPatientId === p.id; return `<div id="paciente-${p.id}" class="${isTarget ? 'text-warning font-weight-bold' : ''}">üßç Paciente ${p.id}: ${p.caso} ${requiredText}</div>`; }).join(''); }
        function getRequiredProductForPatient(patientId) { const patient = pacientes.find(p => p.id === patientId); return patient ? patient.produto : null;}
        function addPatientMarkers() { /* ... Unchanged ... */ patientMarkers.forEach(marker=>scene.remove(marker)); patientMarkers.length=0; pacientes.forEach(p=>{ const isTarget=!phaseComplete && currentMissionIndex < missions.length && missions[currentMissionIndex].type==='treat' && missions[currentMissionIndex].targetPatientId===p.id; let color=0x007bff; let emissiveColor=0x111111; if(isTarget){color=0xffc107; emissiveColor=color;} const product = getRequiredProductForPatient(p.id); let primaryProduct = Array.isArray(product) ? product[0] : product; if(primaryProduct==='venom' || primaryProduct === 'veneno_homeopatico'){color=0xcc00cc; if(isTarget)emissiveColor=color;} else if (primaryProduct === 'water') { color = 0x03a9f4; if(isTarget)emissiveColor=color; } else if (primaryProduct === 'cera') { color = 0xFFA500; if(isTarget)emissiveColor=color; } const geometry=new THREE.SphereGeometry(0.2,16,12); const material=new THREE.MeshStandardMaterial({color:color,emissive:emissiveColor}); const marker=new THREE.Mesh(geometry,material); marker.position.copy(p.position); marker.userData.patientId=p.id; marker.castShadow=true; scene.add(marker); patientMarkers.push(marker);});}

        // REVISED: updateInfoPanel uses currentPhase for styling
        function updateInfoPanel() {
            document.getElementById('carrying-capacity').textContent = `${Object.values(currentlyCarrying).reduce((a, b) => a + b, 0)} / ${carryingCapacity}`;
            let carryingHTML = Object.entries(currentlyCarrying).filter(([_, v]) => v > 0).map(([key, value]) => `<li class="${getClassForResource(key, 'carrying')}"> ${getEmoji(key)} ${capitalize(key)}: ${value}</li>`).join('');
            document.getElementById('carrying-now').innerHTML = carryingHTML || `<li>(Vazio)</li>`;
            let hiveHTML = Object.entries(hiveStorage).map(([key, value]) => `<li class="${getClassForResource(key, 'hive')}"> ${getEmoji(key)} ${capitalize(key)}: ${value}</li>`).join('');
            document.getElementById('hive-storage').innerHTML = hiveHTML;

            const missionHeaderEl = document.getElementById('current-mission');
            let missionClass = 'mission-header'; // Base class
            // Add phase-specific class
            if (currentPhase === 1) missionClass += ' mission-phase1';
            else if (currentPhase === 2) missionClass += ' mission-phase2';
            else if (currentPhase === 3) missionClass += ' mission-phase3';

            // Determine mission text and completion status
            if (phaseComplete && awaitingPhaseTransitionTalk) {
                 // Phase done, waiting for talk - show the *last* mission text
                 const lastMissionDescription = missions.length > 0 ? missions[missions.length - 1].description : "Fase Conclu√≠da!";
                 missionHeaderEl.textContent = lastMissionDescription;
                 missionHeaderEl.className = `${missionClass} text-success`; // Mark as green
            } else if (phaseComplete && !awaitingPhaseTransitionTalk) {
                 // Game truly finished (after final phase)
                  const lastMissionDescription = missions.length > 0 ? missions[missions.length - 1].description : "Todas as Fases Conclu√≠das!";
                 missionHeaderEl.textContent = lastMissionDescription; // Show final message
                 missionHeaderEl.className = `${missionClass} text-success`;
            } else if (currentMissionIndex < missions.length) {
                 // Phase ongoing, show current mission
                 missionHeaderEl.textContent = missions[currentMissionIndex].description;
                 missionHeaderEl.className = missionClass; // Normal style
                 missionHeaderEl.classList.remove('highlight'); // Ensure highlight is off initially
            } else {
                 // Should not happen in normal flow, but good fallback
                 missionHeaderEl.textContent = "Carregando...";
                 missionHeaderEl.className = 'mission-header';
            }

            document.getElementById('nursery-status').textContent = nurseryBuilt ? "üõñ Ber√ß√°rio Constru√≠do" : "";
            updatePacientesUI();
            addPatientMarkers();
        }

        // REVISED: setPhaseIndicator uses currentPhase
        function setPhaseIndicator() {
             const indicatorEl = document.getElementById('phase-indicator');
             indicatorEl.textContent = `(Fase ${currentPhase})`;
             if (currentPhase === 1) indicatorEl.style.color = '#ffc107';
             else if (currentPhase === 2) indicatorEl.style.color = '#00bcd4';
             else if (currentPhase === 3) indicatorEl.style.color = '#ff9800';
             else indicatorEl.style.color = '#ffffff'; // Default
         }

        // --- Helper Functions (Emojis, Capitalize, CSS Classes) --- (Unchanged)
        function getClassForResource(type, location) { switch(type) { case 'venom': return 'venom-storage'; case 'water': return 'water-storage'; case 'veneno_homeopatico': return 'homeopathic-storage'; case 'cera': return 'cera-storage'; default: return location === 'carrying' ? 'carrying' : 'hive'; } }
        function getEmoji(type) { switch(type){case'mel':return'üçØ'; case'propolis':return'ü™µ'; case'polen':return'üåº'; case'geleia':return'üëë'; case'venom':return'‚ò†Ô∏è'; case 'water': return 'üíß'; case 'veneno_homeopatico': return 'üß™'; case 'cera': return 'üß±'; case 'nursery': return 'üõñ'; default:return'‚ùì';}} // Added nursery emoji
        function capitalize(s) { if (!s) return ''; if (s === 'veneno_homeopatico') return 'Veneno Homeop√°tico'; if (s === 'cera') return 'Cera'; return s.charAt(0).toUpperCase()+s.slice(1);}

        // --- Resource Spawning / Management --- (Unchanged)
        const resourceTypes={'mel':{color:0xffc107,geometry:new THREE.SphereGeometry(0.15,8,6)},'propolis':{color:0x6d4c41,geometry:new THREE.BoxGeometry(0.2,0.3,0.2)},'polen':{color:0xff5722,geometry:new THREE.IcosahedronGeometry(0.18,0)},'geleia':{color:0x9c27b0,geometry:new THREE.TorusGeometry(0.15,0.05,8,12),emissive:0x550055}};
        function createResource(type,position){ if(!scene)return; const config=resourceTypes[type]; if(!config)return; const material=new THREE.MeshStandardMaterial({color:config.color,emissive:config.emissive||0x000000}); const resourceMesh=new THREE.Mesh(config.geometry,material); if(!position){const range= currentPhase===3? 35 : (currentPhase === 2 ? 30 : 20); position=new THREE.Vector3((Math.random()-0.5)*range,0.2,(Math.random()-0.5)*range);} if(position.distanceTo(hivePosition)<3)position.x+=3*Math.sign(position.x||1); if (Math.abs(position.x - water.position.x) < (water.geometry.parameters.width / 2 + 1) && Math.abs(position.z - water.position.z) < (water.geometry.parameters.height / 2 + 1)) { position.x += (water.geometry.parameters.width / 2 + 2) * Math.sign(position.x - water.position.x || 1); } resourceMesh.position.copy(position); resourceMesh.userData={type:type}; resourceMesh.castShadow=true; scene.add(resourceMesh); activeResources.push(resourceMesh); return resourceMesh;}
        function createWaterSource() { /* ... Unchanged ... */ if (!scene || !water) return; const waterWidth = water.geometry.parameters.width; const waterHeight = water.geometry.parameters.height; const waterX = water.position.x; const waterZ = water.position.z; const x = waterX + (Math.random() - 0.5) * waterWidth * 0.9; const z = waterZ + (Math.random() - 0.5) * waterHeight * 0.9; const y = 0.3; const waterMesh = new THREE.Mesh(waterSourceGeo, waterSourceMat); waterMesh.position.set(x, y, z); waterMesh.userData = { type: 'waterSource' }; waterMesh.castShadow = true; scene.add(waterMesh); activeWaterSources.push(waterMesh); return waterMesh; }
        function clearOldResources() { /* ... Unchanged ... */ for (let i = activeResources.length - 1; i >= 0; i--) { if (activeResources[i] !== venomSource) { scene.remove(activeResources[i]); activeResources.splice(i, 1); } } for (let i = activeWaterSources.length - 1; i >= 0; i--) { scene.remove(activeWaterSources[i]); activeWaterSources.splice(i, 1); } }
        function spawnInitialResources(){ /* ... Phase 1 ... */ clearOldResources(); if(!scene) return; if (!activeResources.includes(venomSource)) activeResources.push(venomSource); createResource('mel', new THREE.Vector3(3, 0.2, -2)); createResource('propolis', new THREE.Vector3(-3, 0.2, -3)); createResource('polen', new THREE.Vector3(5, 0.2, -6)); createResource('geleia', new THREE.Vector3(-4, 0.2, -5)); for(let i=0; i<5; i++) createResource('mel'); for(let i=0; i<3; i++) createResource('propolis'); for(let i=0; i<4; i++) createResource('polen'); }
        function spawnPhase2Resources() { /* ... Phase 2 ... */ if(!scene) return; if (!activeResources.includes(venomSource)) activeResources.push(venomSource); createResource('mel', new THREE.Vector3(-10, 0.2, -8)); createResource('propolis', new THREE.Vector3(16, 0.2, 6)); createResource('polen', new THREE.Vector3(-12, 0.2, -12)); createResource('geleia', new THREE.Vector3(-6, 0.2, -14)); for(let i=0; i<6; i++) createResource('mel'); for(let i=0; i<7; i++) createResource('propolis'); for(let i=0; i<6; i++) createResource('polen'); }
        function spawnInitialWaterSources() { /* ... Unchanged ... */ if (!scene || !water) return; for (let i = activeWaterSources.length - 1; i >= 0; i--) { scene.remove(activeWaterSources[i]); } activeWaterSources = []; for (let i = 0; i < 8; i++) { createWaterSource(); } }
        function removeResourceFromScene(resourceMesh, isWater = false){ /* ... Unchanged ... */ if (!scene) return; scene.remove(resourceMesh); const sourceArray = isWater ? activeWaterSources : activeResources; const index = sourceArray.indexOf(resourceMesh); if (index > -1) { sourceArray.splice(index, 1); } }
        function respawnResource(type){ /* ... Unchanged ... */ if(type==='venomSource'){ console.log("Venom source cooldown..."); venomSource.userData.active=false; venomSource.visible=false; setTimeout(()=>{if(venomSource&&scene){venomSource.userData.active=true; venomSource.visible=true; console.log("Venom source active."); updateStatus("A fonte de veneno est√° ativa novamente!","info");}},30000);} else if (type === 'waterSource') { setTimeout(() => { createWaterSource(); }, 5000); } else{ setTimeout(()=>{createResource(type);},8000);} }

        // --- Movement Controls & State --- (Unchanged)
        const moveState = { forward: 0, turn: 0, up: 0, down: 0 }; const moveSpeed = 3.0; const turnSpeed = 2.5; const verticalSpeed = 2.0; const maxBeeHeight = 10; const minBeeHeight = 0.3;
        window.addEventListener('keydown', (e) => { switch (e.key.toLowerCase()) { case 'arrowup': case 'w': moveState.forward = 1; break; case 'arrowdown': case 's': moveState.forward = -1; break; case 'arrowleft': case 'a': moveState.turn = 1; break; case 'arrowright': case 'd': moveState.turn = -1; break; case ' ': moveState.up = 1; break; case 'shift': moveState.down = 1; break; case 'e': tryDepositResources(); break; } if ([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'shift'].includes(e.key.toLowerCase())) { e.preventDefault(); } });
        window.addEventListener('keyup', (e) => { switch (e.key.toLowerCase()) { case 'arrowup': case 'w': if (moveState.forward === 1) moveState.forward = 0; break; case 'arrowdown': case 's': if (moveState.forward === -1) moveState.forward = 0; break; case 'arrowleft': case 'a': if (moveState.turn === 1) moveState.turn = 0; break; case 'arrowright': case 'd': if (moveState.turn === -1) moveState.turn = 0; break; case ' ': moveState.up = 0; break; case 'shift': moveState.down = 0; break; } });

        // --- Interaction Logic --- (Unchanged checks, just call checkMissionCompletion)
        const interactionDistance = { resource: 0.4, water: 0.4, patient: 0.5, hive: 1.0, venomSource: 0.5, npc: 1.2 };
        function checkCollisionsAndInteractions() { if (phaseComplete && !awaitingPhaseTransitionTalk) return; /* Stop interactions if phase done and not waiting for talk */ if (!beeGroup || !scene) return; const beePos = beeGroup.position; let interactedThisFrame = false; const totalCarrying=Object.values(currentlyCarrying).reduce((a,b)=>a+b,0); /* Venom */ if (!interactedThisFrame && venomSource && venomSource.userData.active && beePos.distanceTo(venomSource.position) < interactionDistance.venomSource) { if(currentlyCarrying.venom>0){updateStatus("Voc√™ j√° est√° carregando Veneno!","warning");} else if(totalCarrying>=carryingCapacity){updateStatus(`N√£o pode carregar mais! (${totalCarrying}/${carryingCapacity}) Volte.`,"warning");} else{currentlyCarrying.venom++; updateInfoPanel(); updateStatus(`Coletou 1 ${getEmoji('venom')} Veneno! (${totalCarrying+1}/${carryingCapacity})`,'success'); respawnResource('venomSource'); interactedThisFrame=true; checkMissionCompletion(); } } /* Water (P2+) */ if (!interactedThisFrame && currentPhase >= 2 ) { for (let i = activeWaterSources.length - 1; i >= 0; i--) { const waterRes = activeWaterSources[i]; if (!waterRes || !waterRes.position) continue; const distXZ = new THREE.Vector2(beePos.x - waterRes.position.x, beePos.z - waterRes.position.z).length(); const distY = Math.abs(beePos.y - waterRes.position.y); if (distXZ < interactionDistance.water && distY < interactionDistance.water * 1.5) { if (totalCarrying < carryingCapacity) { currentlyCarrying.water++; removeResourceFromScene(waterRes, true); updateInfoPanel(); updateStatus(`Coletou 1 ${getEmoji('water')} √Ågua! (${totalCarrying + 1}/${carryingCapacity})`, 'success'); respawnResource('waterSource'); interactedThisFrame = true; checkMissionCompletion(); } else { updateStatus(`N√£o pode carregar mais! (${totalCarrying}/${carryingCapacity}) Volte.`, 'warning'); } break; } } } /* Generic */ if (!interactedThisFrame) { for (let i = activeResources.length - 1; i >= 0; i--) { const res = activeResources[i]; if (res === venomSource || !res.userData || !res.userData.type) continue; if (beePos.distanceTo(res.position) < interactionDistance.resource) { const type=res.userData.type; if(totalCarrying<carryingCapacity){ currentlyCarrying[type]++; removeResourceFromScene(res); updateInfoPanel(); updateStatus(`Coletou 1 ${getEmoji(type)} ${capitalize(type)}! (${totalCarrying+1}/${carryingCapacity})`,'success'); respawnResource(type); interactedThisFrame=true; checkMissionCompletion(); } else{updateStatus(`N√£o pode carregar mais! (${totalCarrying}/${carryingCapacity}) Volte.`,'warning');} break; } } }
            /* Patients */ if (!interactedThisFrame && !phaseComplete && currentMissionIndex < missions.length) { const mission = missions[currentMissionIndex]; if (mission.type === 'treat') { const targetPatientId = mission.targetPatientId; const markerIndex = patientMarkers.findIndex(m => m.userData.patientId === targetPatientId); if (markerIndex !== -1) { const marker = patientMarkers[markerIndex]; if (beePos.distanceTo(marker.position) < interactionDistance.patient) { const patientIndex = pacientes.findIndex(p => p.id === targetPatientId); if (patientIndex !== -1) { const p = pacientes[patientIndex]; const requiredProducts = p.produto; let productToUse = null; if (Array.isArray(requiredProducts)) { productToUse = requiredProducts.find(prod => hiveStorage[prod] > 0); } else { if (hiveStorage[requiredProducts] > 0) { productToUse = requiredProducts; } } if (productToUse) { hiveStorage[productToUse]--; const treatedCase=p.caso; handlePatientTreated(patientIndex,marker,markerIndex); updateStatus(`Paciente ${p.id} (${treatedCase}) curado com ${getEmoji(productToUse)} ${capitalize(productToUse)}!`,'success'); interactedThisFrame = true; checkMissionCompletion(); } else { let neededStr = ''; if (Array.isArray(requiredProducts)) { neededStr = requiredProducts.map(pr => `${getEmoji(pr)} ${capitalize(pr)}`).join(' ou '); } else { neededStr = `${getEmoji(requiredProducts)} ${capitalize(requiredProducts)}`; } updateStatus(`${neededStr} indispon√≠vel na Colmeia para Paciente ${p.id}!`, 'error'); } } } } } }
        }
        function handlePatientTreated(patientIndex,marker,markerIndex){ /* ... Unchanged ... */ pacientes.splice(patientIndex,1); if(scene)scene.remove(marker); patientMarkers.splice(markerIndex,1); updateInfoPanel();}

        // --- Deposit, Crafting, Building ---
        function tryDepositResources(){ /* ... Unchanged logic, calls helper functions ... */ if (!beeGroup || !hiveGroup) return; const beePos = beeGroup.position; if (beePos.distanceTo(hivePosition) < interactionDistance.hive) { let depositedCount = 0; for (const type in currentlyCarrying) { if (currentlyCarrying[type] > 0 && type !== 'cera') { hiveStorage[type] = (hiveStorage[type] || 0) + currentlyCarrying[type]; depositedCount += currentlyCarrying[type]; currentlyCarrying[type] = 0; } } if (depositedCount > 0) { updateInfoPanel(); let craftedItems = checkForCrafting(); let builtSomething = checkForBuilding(); let statusMsg = `${depositedCount} itens depositados!`; if (craftedItems.length > 0) statusMsg += ` ${craftedItems.map(item => `+${item.count} ${getEmoji(item.type)}`).join(', ')} criado(s)!`; if (builtSomething) statusMsg += ` ${getEmoji('nursery')} Ber√ß√°rio constru√≠do!`; updateStatus(statusMsg, 'success'); checkMissionCompletion(); } else { updateStatus(`Nada para depositar.`, 'info'); } } else { updateStatus(`Aproxime-se mais da Colmeia para depositar (Tecla 'E').`, 'warning'); } }
        function checkForCrafting() { /* ... Unchanged logic for Venom/Cera ... */ let craftedItems = []; /* Venom (P2+) */ if (currentPhase >= 2) { const mission = (currentMissionIndex < missions.length) ? missions[currentMissionIndex] : null; const needsVenomCraftMission = mission && mission.type === 'craft' && mission.yields === 'veneno_homeopatico'; const venomNeeded = needsVenomCraftMission ? mission.requires.venom : 1; const waterNeeded = needsVenomCraftMission ? mission.requires.water : 3; const goal = needsVenomCraftMission ? mission.goal : 0; if (needsVenomCraftMission && hiveStorage.veneno_homeopatico < goal && hiveStorage.venom >= venomNeeded && hiveStorage.water >= waterNeeded) { hiveStorage.venom -= venomNeeded; hiveStorage.water -= waterNeeded; hiveStorage.veneno_homeopatico++; craftedItems.push({ type: 'veneno_homeopatico', count: 1 }); console.log("Crafted Homeopathic Venom"); } } /* Cera (P3+) */ if (currentPhase >= 3) { const ceraRecipe = { mel: 3, water: 3, polen: 1 }; while (hiveStorage.mel >= ceraRecipe.mel && hiveStorage.water >= ceraRecipe.water && hiveStorage.polen >= ceraRecipe.polen) { hiveStorage.mel -= ceraRecipe.mel; hiveStorage.water -= ceraRecipe.water; hiveStorage.polen -= ceraRecipe.polen; hiveStorage.cera++; let ceraEntry = craftedItems.find(item => item.type === 'cera'); if (ceraEntry) { ceraEntry.count++; } else { craftedItems.push({ type: 'cera', count: 1 }); } console.log("Crafted Cera"); } } if (craftedItems.length > 0) { updateInfoPanel(); } return craftedItems; }
        function checkForBuilding() { /* ... Unchanged logic ... */ if (currentPhase !== 3 || nurseryBuilt) return false; const mission = (currentMissionIndex < missions.length) ? missions[currentMissionIndex] : null; if (mission && mission.type === 'build_nursery' && hiveStorage.cera >= 6) { hiveStorage.cera -= 6; nurseryBuilt = true; buildNurseryVisuals(); updateInfoPanel(); console.log("Nursery Built!"); return true; } return false; }
        function buildNurseryVisuals() { /* ... Unchanged logic ... */ if (nurseryMesh || !hiveGroup) return; const hexagonShape = new THREE.Shape(); const size = 0.5; const H = Math.sqrt(3) * size; hexagonShape.moveTo(size, 0); hexagonShape.lineTo(size / 2, H / 2); hexagonShape.lineTo(-size / 2, H / 2); hexagonShape.lineTo(-size, 0); hexagonShape.lineTo(-size / 2, -H / 2); hexagonShape.lineTo(size / 2, -H / 2); hexagonShape.lineTo(size, 0); const extrudeSettings = { depth: 0.2, bevelEnabled: false }; const geometry = new THREE.ExtrudeGeometry(hexagonShape, extrudeSettings); const material = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, side: THREE.DoubleSide }); nurseryMesh = new THREE.Mesh(geometry, material); const hiveRadius = hiveBase.geometry.parameters.radiusTop; const nurseryOffset = hiveRadius + size * 0.8; nurseryMesh.position.set(nurseryOffset, -0.3, 0); nurseryMesh.rotation.x = -Math.PI / 2; nurseryMesh.castShadow = true; nurseryMesh.receiveShadow = true; hiveGroup.add(nurseryMesh); console.log("Nursery mesh added to scene at", nurseryMesh.position); }

        // --- Mission Logic (Revised) ---
        function checkMissionCompletion() {
             // Exit checks: Phase already done? Invalid index? No mission defined?
             if (phaseComplete || currentMissionIndex >= missions.length) return;
             const mission = missions[currentMissionIndex];
             if (!mission) { console.error("Mission definition missing at index", currentMissionIndex); return; }

             let completedCurrent = false;

             // Check completion criteria
             switch (mission.type) {
                 case 'collect': case 'collect_special':
                     if ((hiveStorage[mission.target] || 0) >= mission.goal) completedCurrent = true;
                     break;
                 case 'treat':
                     if (!pacientes.some(p => p.id === mission.targetPatientId)) completedCurrent = true;
                     break;
                 case 'craft':
                      if ((hiveStorage[mission.yields] || 0) >= mission.goal) completedCurrent = true;
                     break;
                 case 'build_nursery':
                      if (nurseryBuilt) completedCurrent = true;
                      break;
                 case 'complete_phase1': case 'complete_phase2': case 'complete_phase3':
                     completedCurrent = true; // Mark as complete when reached
                     break;
                 default:
                      console.warn("Unknown mission type:", mission.type);
                      break; // Unknown type, cannot complete
             }

             if (completedCurrent) {
                 const oldMissionDesc = mission.description;
                 console.log(`Mission Completed: ${mission.id} (${currentPhase}-${currentMissionIndex}) - ${oldMissionDesc}`);

                 // Handle Phase Completion
                 if (mission.type === 'complete_phase1' || mission.type === 'complete_phase2' || mission.type === 'complete_phase3') {
                      phaseComplete = true; // Mark the current phase as done
                      if (mission.type !== 'complete_phase3') { // Only wait for talk if not the final phase
                         awaitingPhaseTransitionTalk = true;
                         // Set the correct prompt dialogue for the NPC
                         if (mission.type === 'complete_phase1') apicultorNPC.userData.currentDialogueId = 'phase1_complete_prompt';
                         else if (mission.type === 'complete_phase2') apicultorNPC.userData.currentDialogueId = 'phase2_complete_prompt';
                         updateStatus(`Fase ${currentPhase} Conclu√≠da! Fale com o Apicultor.`, "success");
                      } else {
                         // Final phase completed
                         awaitingPhaseTransitionTalk = false; // No next phase talk
                         apicultorNPC.userData.currentDialogueId = 'phase3_complete_final';
                         updateStatus("Parab√©ns! Todas as Fases Conclu√≠das!", "success");
                      }
                 }
                 // Handle Standard Mission Completion
                 else {
                     currentMissionIndex++; // Advance to the next mission *within the current phase*
                     updateStatus(`Miss√£o Conclu√≠da: ${oldMissionDesc}`, 'success');
                     const missionHeaderEl = document.getElementById('current-mission');
                     if (missionHeaderEl) { missionHeaderEl.classList.add('highlight'); setTimeout(() => missionHeaderEl.classList.remove('highlight'), 2000); }

                     // Check if the *new* current mission is a phase completion one, and trigger its logic immediately
                      if (currentMissionIndex < missions.length && missions[currentMissionIndex].type.startsWith('complete_')) {
                          console.log("Immediately checking phase complete mission:", missions[currentMissionIndex].id);
                          checkMissionCompletion(); // Run check again for the completion mission
                      }
                 }
                 updateInfoPanel(); // Update UI regardless of mission type
             }
        }

        // --- Minimap Drawing --- (Unchanged)
        function updateMinimap(){ if(!minimapCtx||!scene)return; minimapCtx.fillStyle='rgba(0,0,0,0.6)'; minimapCtx.fillRect(0,0,minimapSize,minimapSize); const waterMapPos = worldToMinimap(water.position); const waterMapWidth = (water.geometry.parameters.width / minimapWorldSize) * minimapSize; const waterMapHeight = (water.geometry.parameters.height / minimapWorldSize) * minimapSize; minimapCtx.fillStyle = 'rgba(70, 130, 180, 0.5)'; minimapCtx.fillRect(waterMapPos.x - waterMapWidth/2, waterMapPos.y - waterMapHeight/2, waterMapWidth, waterMapHeight); if(hiveGroup){drawMinimapMarker(minimapCtx,hiveGroup.position,'#DAA520',5,'square'); if(nurseryBuilt && nurseryMesh){ const nurseryWorldPos = new THREE.Vector3(); nurseryMesh.getWorldPosition(nurseryWorldPos); drawMinimapMarker(minimapCtx, nurseryWorldPos, '#F5F5DC', 3, 'hexagon'); }} activeResources.forEach(res=>{if(!res||!res.position)return; if(res===venomSource){if(res.userData.active)drawMinimapMarker(minimapCtx,res.position,'#9400D3',4);}else if(res.userData&&res.userData.type){let c='#888'; switch(res.userData.type){case'mel':c='#FFC107';break; case'propolis':c='#6D4C41';break; case'polen':c='#FF5722';break; case'geleia':c='#9C27B0';break;} drawMinimapMarker(minimapCtx,res.position,c,2);}}); activeWaterSources.forEach(res => { if(!res || !res.position) return; drawMinimapMarker(minimapCtx, res.position, '#03a9f4', 2); }); patientMarkers.forEach(marker=>{ if(!marker||!marker.position)return; const p=pacientes.find(pt=>pt.id===marker.userData.patientId); if(!p)return; const isTarget=!phaseComplete && currentMissionIndex < missions.length && missions[currentMissionIndex].type==='treat' && missions[currentMissionIndex].targetPatientId===p.id; let c= '#007bff'; const product = getRequiredProductForPatient(p.id); let primaryProduct = Array.isArray(product) ? product[0] : product; if (primaryProduct === 'venom' || primaryProduct === 'veneno_homeopatico') c = '#cc00cc'; else if (primaryProduct === 'water') c = '#03a9f4'; else if (primaryProduct === 'cera') c = '#FFA500'; if(isTarget)c='#FFFF00'; drawMinimapMarker(minimapCtx,marker.position,c,3);}); if (apicultorNPC) drawMinimapMarker(minimapCtx, apicultorNPC.position, '#CCCCCC', 4, 'square'); if (beeGroup)drawMinimapMarker(minimapCtx,beeGroup.position,'#FFFFFF',4); }
        function worldToMinimap(worldPos){ const mapX=(worldPos.x/minimapWorldSize)*minimapSize+minimapSize/2; const mapY=(-worldPos.z/minimapWorldSize)*minimapSize+minimapSize/2; return{x:mapX, y:mapY};}
        function drawMinimapMarker(ctx,pos,color,size=3,shape='circle'){ if(!pos)return; const mapPos=worldToMinimap(pos); const cX=Math.max(size,Math.min(minimapSize-size,mapPos.x)); const cY=Math.max(size,Math.min(minimapSize-size,mapPos.y)); ctx.fillStyle=color; if(shape==='circle'){ctx.beginPath(); ctx.arc(cX,cY,size,0,Math.PI*2); ctx.fill();}else if(shape==='square'){ctx.fillRect(cX-size/2,cY-size/2,size,size);} else if (shape === 'hexagon') { const angle = Math.PI / 3; ctx.beginPath(); for (let i = 0; i < 6; i++) { ctx.lineTo(cX + size * Math.cos(angle * i), cY + size * Math.sin(angle * i)); } ctx.closePath(); ctx.fill(); }}

        // REVISED: updateNPCDialogProximity uses reliable state flags
        function updateNPCDialogProximity() {
            if (!apicultorNPC || !dialogBox || !beeGroup) return;
            const distance = beeGroup.position.distanceTo(apicultorNPC.position);
            const isCurrentlyVisible = dialogBox.classList.contains('visible');

            if (distance < interactionDistance.npc) {
                 // Determine the correct dialogue ID based on game state
                 // The NPC's currentDialogueId should already be set correctly by checkMissionCompletion or startPhaseX
                 let targetDialogueId = apicultorNPC.userData.currentDialogueId;

                 // Override if very start of game
                 if (currentPhase === 1 && currentMissionIndex === 0 && !phaseComplete) {
                    targetDialogueId = 'welcome';
                 }
                 // Ensure the prompt is shown if waiting for talk
                 else if (awaitingPhaseTransitionTalk) {
                     if (currentPhase === 1 && phaseComplete) targetDialogueId = 'phase1_complete_prompt';
                     else if (currentPhase === 2 && phaseComplete) targetDialogueId = 'phase2_complete_prompt';
                 }
                  // Ensure the final message is shown if phase 3 is complete
                 else if (currentPhase === 3 && phaseComplete) {
                    targetDialogueId = 'phase3_complete_final';
                 }

                 // Update NPC state if determined ID differs from stored one
                 if (apicultorNPC.userData.currentDialogueId !== targetDialogueId) {
                     console.log(`Updating NPC dialogue from ${apicultorNPC.userData.currentDialogueId} to ${targetDialogueId}`);
                     apicultorNPC.userData.currentDialogueId = targetDialogueId;
                     delete apicultorNPC.userData.currentDisplayedDialogueId; // Force redraw if ID changed
                 }

                 showDialog(apicultorNPC); // ShowDialog handles visibility and content update

            } else {
                // Player is too far - hide the dialog if it was showing for THIS npc
                if (isCurrentlyVisible && currentNpc === apicultorNPC) {
                    hideDialog();
                }
            }
        }


        // --- Animation Loop --- (Unchanged structure)
        function animate() { requestAnimationFrame(animate); const delta = clock.getDelta(); /* Movement */ if (moveState.turn !== 0) beeGroup.rotation.y += moveState.turn * turnSpeed * delta; let moveVector = new THREE.Vector3(); if (moveState.forward !== 0) { const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(beeGroup.quaternion); moveVector.addScaledVector(forward, moveState.forward * moveSpeed * delta); } beeGroup.position.add(moveVector); let targetY = beeGroup.position.y; if (moveState.up !== 0) targetY += verticalSpeed * delta; if (moveState.down !== 0) targetY -= verticalSpeed * delta; beeGroup.position.y = Math.max(minBeeHeight, Math.min(maxBeeHeight, targetY)); /* Wing Flapping */ const isMoving = moveState.forward !== 0 || moveState.turn !== 0 || moveState.up !== 0 || moveState.down !== 0; const wingSpeed = isMoving ? 35 : 10; const wingAngle = Math.sin(clock.getElapsedTime() * wingSpeed) * (isMoving ? Math.PI / 6 : Math.PI / 12); if(lWing) lWing.rotation.z = wingAngle; if(rWing) rWing.rotation.z = -wingAngle; /* Interactions */ checkCollisionsAndInteractions(); /* Check needs to happen even if phase complete, to allow talking */ /* NPC Dialog */ updateNPCDialogProximity(); /* Minimap */ if ( (performance.now() * 0.003) % 1 < delta * 3 ) { updateMinimap(); } /* Camera */ const cameraOffset = new THREE.Vector3(0, 1.5+(beeGroup.position.y*0.5), 5+(beeGroup.position.y*0.2)); const desiredCameraPosition = beeGroup.position.clone().add(cameraOffset.applyQuaternion(beeGroup.quaternion)); const lookAtPosition = beeGroup.position.clone().add(new THREE.Vector3(0,0.2,0)); camera.position.lerp(desiredCameraPosition, 0.08); camera.lookAt(lookAtPosition); /* Water */ if (water && water.geometry) { const time = clock.getElapsedTime()*1.5; const posAttr = water.geometry.attributes.position; for (let i=0; i<posAttr.count; i++) { const x=posAttr.getX(i); const y=posAttr.getY(i); posAttr.setZ(i, Math.sin(x*0.5+time)*0.05 + Math.cos(y*0.5+time*0.8)*0.05); } posAttr.needsUpdate = true; } renderer.render(scene, camera); }

        // --- Initial Setup Calls (Revised) ---
        function initializeGame() {
            currentPhase = 1;
            missions = phase1Missions;
            pacientes = [...phase1Patients];
            currentMissionIndex = 0;
            phaseComplete = false;
            awaitingPhaseTransitionTalk = false;
            hasReceivedTrophy = false;
            nurseryBuilt = false;
            if (nurseryMesh) { hiveGroup.remove(nurseryMesh); nurseryMesh = null; }
            Object.keys(currentlyCarrying).forEach(k => currentlyCarrying[k] = 0);
            Object.keys(hiveStorage).forEach(k => hiveStorage[k] = 0);
            apicultorNPC.userData.currentDialogueId = 'welcome'; // Initial state
            delete apicultorNPC.userData.currentDisplayedDialogueId;
            document.getElementById('trophy-display').textContent = "";
            document.getElementById('nursery-status').textContent = "";
            setPhaseIndicator(); // Set phase 1 indicator

            updateInfoPanel();
            spawnInitialResources();
            hideDialog();
            updateMinimap();
            checkMissionCompletion(); // Check if mission 0 is somehow complete
        }

        initializeGame();
        animate();

        // --- Resize Listener --- (Unchanged)
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }, false);

    </script>
</body>
</html>
